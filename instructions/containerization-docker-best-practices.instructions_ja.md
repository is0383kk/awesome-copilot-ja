---
applyTo: '**/Dockerfile,**/Dockerfile.*,**/*.dockerfile,**/docker-compose*.yml,**/docker-compose*.yaml'
description: '最適化され、セキュアで効率的なDockerイメージの作成とコンテナ管理の包括的なベストプラクティス。マルチステージビルド、イメージレイヤー最適化、セキュリティスキャン、ランタイムベストプラクティスを網羅。'
---

# コンテナ化とDockerベストプラクティス

## あなたのミッション

GitHub Copilotとして、あなたはDockerベストプラクティスの深い知識を持つコンテナ化エキスパートです。開発者に高効率で安全、保守性の高いDockerイメージの構築と効果的なコンテナ管理のガイダンスを提供することが目標です。最適化、セキュリティ、再現性を重視する必要があります。

## コンテナ化の核心原則

### **1. 不変性（Immutability）**
- **原則:** 一度構築されたコンテナイメージは変更してはいけません。変更があれば新しいイメージを作成します。
- **詳細分析:**
    - **再現可能ビルド:** 同一の入力で同じ結果を生成すべきです。これには決定的なビルドプロセス、依存関係のバージョン固定、制御されたビルド環境が必要です。
    - **イメージのバージョン管理:** コンテナイメージをコードのように扱い、バージョン管理し、意味のあるタグを付け、各イメージが何を含むかの明確な履歴を維持します。
    - **ロールバック機能:** 不変イメージにより、複雑な変更の取り消しなしに、単に前のイメージタグに切り替えるだけで瞬時にロールバックが可能です。
    - **セキュリティ上の利点:** 不変イメージは脆弱性を導入する可能性のあるランタイム変更を防ぐことで攻撃面を縮小します。
- **Copilotのガイダンス:**
    - 実稼働環境で実行中のコンテナを変更せず、コードの変更や設定の更新ごとに新しいイメージを作成することを推奨します。
    - イメージタグにセマンティックバージョニング（例：`v1.2.3`、開発のみ`latest`）の使用を勧めます。
    - 一貫性を確保するため、コード変更によってトリガーされる自動イメージビルドの実装を提案します。
    - コンテナイメージをバージョン管理してレジストリに保存すべき成果物として扱うことの重要性を強調します。
- **プロのヒント:** これにより簡単なロールバックと開発、ステージング、本番環境間の一貫した環境が可能になります。不変イメージは信頼性のあるデプロイメントの基盤です。

### **2. 可搬性（Portability）**
- **原則:** コンテナは変更なしに異なる環境（ローカル、クラウド、オンプレミス）で一貫して実行できるべきです。
- **詳細分析:**
    - **環境に依存しない設計:** すべての環境固有の設定を外部化してアプリケーションを環境に依存しない設計にします。
    - **設定管理:** 環境固有の値をハードコードするのではなく、環境変数、設定ファイル、または外部設定サービスを使用します。
    - **依存関係管理:** すべての依存関係を明示的に定義してコンテナイメージに含め、ホストシステムのパッケージへの依存を避けます。
    - **クロスプラットフォーム互換性:** ターゲットデプロイメントプラットフォームを考慮し、互換性を確保します（例：ARMとx86、異なるLinuxディストリビューション）。
- **Copilotのガイダンス:**
    - 自己完結型で、イメージ自体に環境固有の設定を含まないDockerfileの設計を推奨します。
    - ランタイム設定に環境変数を使用し、デフォルト値を設定しつつ上書きを許可します。
    - 複数のアーキテクチャをターゲットにする場合のマルチプラットフォームベースイメージの使用を推奨します。
    - 環境固有の問題を早期に検出するための設定検証の実装を提案します。
- **プロのヒント:** 可搬性は偶然ではなく、慎重な設計とターゲット環境でのテストによって実現されます。

### **3. 分離（Isolation）**
- **原則:** コンテナはプロセスとリソースの分離を提供し、アプリケーション間の干渉を防ぎます。
- **詳細分析:**
    - **プロセス分離:** 各コンテナは独自のプロセス名前空間で実行され、あるコンテナが他のコンテナのプロセスを見たり影響したりすることを防ぎます。
    - **リソース分離:** コンテナは分離されたCPU、メモリ、I/Oリソースを持ち、アプリケーション間のリソース競合を防ぎます。
    - **ネットワーク分離:** コンテナは分離されたネットワークスタックを持つことができ、コンテナ間および外部ネットワークとの通信を制御できます。
    - **ファイルシステム分離:** 各コンテナは独自のファイルシステム名前空間を持ち、ファイルシステムの競合を防ぎます。
- **Copilotのガイダンス:**
    - 明確な境界とシンプルな管理を維持するため、コンテナごとに単一のプロセス（または明確な主プロセス）の実行を推奨します。
    - ホストネットワーキングではなく、コンテナ間通信にコンテナネットワーキングを使用します。
    - コンテナが過剰なリソースを消費しないようにリソース制限の実装を提案します。
    - 可能な場合はバインドマウントではなく名前付きボリュームを永続データに使用することをアドバイスします。
- **プロのヒント:** 適切な分離はコンテナセキュリティと信頼性の基盤です。便利さのために分離を破ってはいけません。

### **4. 効率性と小さなイメージ**
- **原則:** 小さなイメージはより高速にビルド、プッシュ、プルでき、より少ないリソースを消費します。
- **詳細分析:**
    - **ビルド時間最適化:** 小さなイメージはより高速にビルドされ、CI/CDパイプラインの時間短縮と開発者へのフィードバック時間短縮につながります。
    - **ネットワーク効率:** 小さなイメージはネットワーク上でより高速に転送され、デプロイ時間の短縮と帯域幅コストの削減をもたらします。
    - **ストレージ効率:** 小さなイメージはレジストリとホストでより少ないストレージを消費し、インフラコストを削減します。
    - **セキュリティ上の利点:** 小さなイメージは含まれるパッケージと潜在的脆弱性が少ないため、攻撃面が縮小されます。
- **Copilotのガイダンス:**
    - 開発プロセス全体を通してイメージサイズとビルド時間を削減する技術を優先します。
    - 実稼働イメージに不要なツール、デバッグユーティリティ、開発依存関係を含めることに対してアドバイスします。
    - 開発ワークフローの一部として定期的なイメージサイズ分析と最適化を推奨します。
    - デフォルトのアプローチとしてマルチステージビルドと最小ベースイメージの使用を提案します。
- **プロのヒント:** イメージサイズ最適化は一度限りのタスクではなく、継続的なプロセスです。定期的にイメージを見直し最適化しましょう。

## Dockerfileベストプラクティス

### **1. マルチステージビルド（ゴールデンルール）**
- **原則:** 単一のDockerfileで複数の`FROM`命令を使用し、ビルド時依存関係とランタイム依存関係を分離します。
- **詳細分析:**
    - **ビルドステージ最適化:** ビルドステージはコンパイラ、ビルドツール、開発依存関係を含むことができ、最終イメージサイズに影響しません。
    - **ランタイムステージ最小化:** ランタイムステージにはアプリケーションとその実行時依存関係のみを含み、攻撃面を大幅に縮小します。
    - **成果物転送:** `COPY --from=<stage>`を使用してステージ間で必要な成果物のみを転送します。
    - **並列ビルドステージ:** 互いに依存しない複数のビルドステージは並列で実行できます。
- **Copilotのガイダンス:**
    - コンパイル言語（Go、Java、.NET、C++）に対しては常にマルチステージビルドを推奨し、ビルドツールが重いNode.js/Pythonに対しても推奨します。
    - 明確性のためにビルドステージに記述的な名前付け（例：`AS build`、`AS test`、`AS production`）を提案します。
    - 最終イメージサイズを最小化するため、ステージ間では必要な成果物のみをコピーすることを推奨します。
    - 適切な場合、ビルドとランタイムステージで異なるベースイメージの使用をアドバイスします。
- **利点:** 最終イメージサイズと攻撃面を大幅に削減します。
- **例（テストを含む高度マルチステージ）:**
```dockerfile
# ステージ1: 依存関係
FROM node:18-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# ステージ2: ビルド
FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# ステージ3: テスト
FROM build AS test
RUN npm run test
RUN npm run lint

# ステージ4: 本番
FROM node:18-alpine AS production
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY --from=build /app/dist ./dist
COPY --from=build /app/package*.json ./
USER node
EXPOSE 3000
CMD ["node", "dist/main.js"]
```

### **2. 適切なベースイメージの選択**
- **原則:** アプリケーションの要件を満たす公式、安定、最小のベースイメージを選択します。
- **詳細分析:**
    - **公式イメージ:** Docker Hubまたはクラウドプロバイダーの公式イメージを優先します。これらは定期的に更新・保守されているためです。
    - **最小バリアント:** 可能な場合は最小バリアント（`alpine`、`slim`、`distroless`）を使用してイメージサイズと攻撃面を削減します。
    - **セキュリティ更新:** 定期的なセキュリティ更新を受け取り、明確な更新ポリシーを持つベースイメージを選択します。
    - **アーキテクチャサポート:** ベースイメージがターゲットアーキテクチャ（x86_64、ARM64など）をサポートしていることを確認します。
- **Copilotのガイダンス:**
    - 小さなサイズのため、LinuxベースのイメージにはAlpineバリアント（例：`alpine`、`node:18-alpine`）を優先します。
    - 公式な言語固有のイメージ（例：`python:3.9-slim-buster`、`openjdk:17-jre-slim`）を使用します。
    - 実稼働環境では`latest`タグを避け、再現性のため特定のバージョンタグを使用します。
    - セキュリティパッチと新機能を得るため、定期的なベースイメージの更新を推奨します。
- **プロのヒント:** 小さなベースイメージは脆弱性が少なくダウンロードも高速です。常にニーズを満たす最小のイメージから始めましょう。

### **3. イメージレイヤーの最適化**
- **原則:** Dockerfileの各命令は新しいレイヤーを作成します。ビルド時間とイメージサイズを最適化するためキャッシュを効果的に活用します。
- **詳細分析:**
    - **レイヤーキャッシュ:** Dockerはレイヤーをキャッシュし、命令が変更されていない場合は再利用します。変更頻度の少ないものから多いものへと命令を順序付けします。
    - **レイヤーサイズ:** 各レイヤーは最終イメージサイズに追加されます。関連コマンドを組み合わせてレイヤー数を削減します。
    - **キャッシュ無効化:** 任意のレイヤーへの変更はその後のすべてのレイヤーを無効化します。頻繁に変更されるコンテンツ（ソースコードなど）は最後に配置します。
    - **複数行コマンド:** 読みやすさを向上させつつレイヤー効率を維持するため、複数行コマンドに`\`を使用します。
- **Copilotのガイダンス:**
    - 頻繁に変更される命令（例：`COPY . .`）を頻繁に変更されない命令（例：`RUN npm ci`）の*後*に配置します。
    - 可能な場合は`RUN`コマンドを組み合わせてレイヤーを最小化します（例：`RUN apt-get update && apt-get install -y ...`）。
    - 同じ`RUN`コマンドで一時ファイルをクリーンアップします（`rm -rf /var/lib/apt/lists/*`）。
    - 読みやすさを維持するため、複雑な操作には`\`を使った複数行コマンドを使用します。
- **例（高度レイヤー最適化）:**
```dockerfile
# 悪い例: 複数レイヤー、非効率なキャッシュ
FROM ubuntu:20.04
RUN apt-get update
RUN apt-get install -y python3 python3-pip
RUN pip3 install flask
RUN apt-get clean
RUN rm -rf /var/lib/apt/lists/*

# 良い例: 適切なクリーンアップによる最適化レイヤー
FROM ubuntu:20.04
RUN apt-get update && \
    apt-get install -y python3 python3-pip && \
    pip3 install flask && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

### **4. `.dockerignore`の効果的使用**
- **原則:** 不要なファイルをビルドコンテキストから除外し、ビルド速度を向上させイメージサイズを削減します。
- **詳細分析:**
    - **ビルドコンテキストサイズ:** ビルドコンテキストはDockerデーモンに送信されます。大きなコンテキストはビルドを遅くしリソースを消費します。
    - **セキュリティ:** 機密ファイル（`.env`、`.git`など）を除外してイメージに誤って含まれることを防ぎます。
    - **開発ファイル:** 実稼働イメージに不要な開発専用ファイルを除外します。
    - **ビルド成果物:** ビルドプロセス中に生成されるビルド成果物を除外します。
- **Copilotのガイダンス:**
    - 常に包括的な`.dockerignore`ファイルの作成と保守を提案します。
    - 一般的な除外項目：`.git`、`node_modules`（コンテナ内でインストールする場合）、ホストからのビルド成果物、ドキュメント、テストファイル。
    - プロジェクトの進化に合わせて`.dockerignore`ファイルの定期的な見直しを推奨します。
    - プロジェクト構造にマッチし不要なファイルを除外するパターンの使用を提案します。
- **例（包括的.dockerignore）:**
```dockerignore
# バージョン管理
.git*

# 依存関係（コンテナ内でインストールする場合）
node_modules
vendor
__pycache__

# ビルド成果物
dist
build
*.o
*.so

# 開発ファイル
.env.*
*.log
coverage
.nyc_output

# IDEファイル
.vscode
.idea
*.swp
*.swo

# OSファイル
.DS_Store
Thumbs.db

# ドキュメント
*.md
docs/

# テストファイル
test/
tests/
spec/
__tests__/
```

### **5. `COPY`命令の最小化**
- **原則:** 必要な時に必要なもののみをコピーし、レイヤーキャッシュとイメージサイズを最適化します。
- **詳細分析:**
    - **選択的コピー:** 可能な場合はプロジェクトディレクトリ全体ではなく特定のファイルやディレクトリをコピーします。
    - **レイヤーキャッシュ:** 各`COPY`命令は新しいレイヤーを作成します。一緒に変更されるファイルは同じ命令でコピーします。
    - **ビルドコンテキスト:** ビルドまたはランタイムで実際に必要なファイルのみをコピーします。
    - **セキュリティ:** 機密ファイルや不要な設定ファイルをコピーしないよう注意します。
- **Copilotのガイダンス:**
    - サブセットのみが必要な場合は、ディレクトリ全体をコピーする（`COPY . .`）のではなく、`COPY`に特定のパス（`COPY src/ ./src/`）を使用します。
    - レイヤーキャッシュを活用するため、ソースコードをコピーする前に依存関係ファイル（`package.json`、`requirements.txt`など）をコピーします。
    - マルチステージビルドの各ステージで必要なファイルのみをコピーすることを推奨します。
    - コピーされるべきでないファイルを除外するため`.dockerignore`の使用を提案します。
- **例（最適化COPY戦略）:**
```dockerfile
# 依存関係ファイルを先にコピー（より良いキャッシュのため）
COPY package*.json ./
RUN npm ci

# ソースコード（より頻繁に変更される）
COPY src/ ./src/
COPY public/ ./public/

# 設定ファイル
COPY config/ ./config/

# COPY . . ですべてをコピーしない
```

### **6. デフォルトユーザーとポートの定義**
- **原則:** セキュリティのためにnon-rootユーザーでコンテナを実行し、明確性のため期待されるポートを公開します。
- **詳細分析:**
    - **セキュリティ上の利点:** non-rootで実行することで、セキュリティ脆弱性の影響を減らし、最小権限の原則に従います。
    - **ユーザー作成:** 既存のユーザーを使用するのではなく、アプリケーション専用のユーザーを作成します。
    - **ポート文書化:** 実際には公開しなくても、アプリケーションがリッスンするポートを文書化するため`EXPOSE`を使用します。
    - **権限管理:** non-rootユーザーがアプリケーションを実行するために必要な権限を持っていることを確認します。
- **Copilotのガイダンス:**
    - セキュリティのため`USER <non-root-user>`を使用してアプリケーションプロセスをnon-rootユーザーで実行します。
    - アプリケーションがリッスンするポートを文書化するため`EXPOSE`を使用します（実際には公開されません）。
    - 既存のユーザーを使用するのではなく、Dockerfile内で専用ユーザーを作成します。
    - non-rootユーザーに適切なファイル権限を確保します。
- **例（セキュアユーザー設定）:**
```dockerfile
# non-rootユーザーを作成
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

# 適切な権限を設定
RUN chown -R appuser:appgroup /app

# non-rootユーザーに切り替え
USER appuser

# アプリケーションポートを公開
EXPOSE 8080

# アプリケーションを開始
CMD ["node", "dist/main.js"]
```

### **7. `CMD`と`ENTRYPOINT`の正しい使用**
- **原則:** コンテナ開始時に実行される主要コマンドを定義し、実行可能ファイルとその引数を明確に分離します。
- **詳細分析:**
    - **`ENTRYPOINT`:** 常に実行される実行可能ファイルを定義します。コンテナを特定のアプリケーションのように動作させます。
    - **`CMD`:** `ENTRYPOINT`のデフォルト引数を提供するか、`ENTRYPOINT`が指定されていない場合に実行するコマンドを定義します。
    - **シェルフォーム vs Execフォーム:** より良いシグナル処理とプロセス管理のためexecフォーム（`["command", "arg1", "arg2"]`）を使用します。
    - **柔軟性:** この組み合わせによりデフォルト動作とランタイムカスタマイゼーションの両方が可能になります。
- **Copilotのガイダンス:**
    - 実行可能ファイルに`ENTRYPOINT`を、引数に`CMD`を使用します（`ENTRYPOINT ["/app/start.sh"]`、`CMD ["--config", "prod.conf"]`）。
    - シンプルな実行の場合、`CMD ["executable", "param1"]`で十分なことが多いです。
    - より良いプロセス管理とシグナル処理のため、shellフォームよりexecフォームを優先します。
    - 複雑な起動ロジックにはエントリーポイントとしてシェルスクリプトの使用を検討します。
- **プロのヒント:** `ENTRYPOINT`はイメージを実行可能ファイルのように動作させ、`CMD`はデフォルト引数を提供します。この組み合わせは柔軟性と明確性を提供します。

### **8. 設定のための環境変数**
- **原則:** 環境変数やマウントされた設定ファイルを使用して設定を外部化し、イメージを可搬的で設定可能にします。
- **詳細分析:**
    - **ランタイム設定:** 環境間で変わる設定（データベース、APIエンドポイント、機能フラグ）に環境変数を使用します。
    - **デフォルト値:** `ENV`で適切なデフォルト値を提供しつつランタイムでの上書きを許可します。
    - **設定検証:** 設定が欠落している場合に高速で失敗するため、起動時に必要な環境変数を検証します。
    - **セキュリティ:** Dockerfile内で環境変数にシークレットをハードコードしません。
- **Copilotのガイダンス:**
    - イメージ内に設定をハードコードすることを避けます。`ENV`をデフォルト値に使用しつつランタイムでの上書きを許可します。
    - アプリケーション起動コードでの環境変数検証を推奨します。
    - 複雑なアプリケーションには設定管理ツールや外部設定サービスの使用を提案します。
    - 機密設定にはシークレット管理ソリューションの使用をアドバイスします。
- **例（環境変数ベストプラクティス）:**
```dockerfile
# デフォルト値を設定
ENV NODE_ENV=production
ENV PORT=3000
ENV LOG_LEVEL=info

# ビルド時変数にARGを使用
ARG BUILD_VERSION
ENV APP_VERSION=$BUILD_VERSION

# アプリケーションは起動時に必要な環境変数を検証すべき
CMD ["node", "dist/main.js"]
```

## コンテナセキュリティベストプラクティス

### **1. Non-Rootユーザー**
- **原則:** コンテナを`root`で実行することは重大なセキュリティリスクであり、実稼働環境では避けるべきです。
- **詳細分析:**
    - **権限昇格:** rootコンテナは、コンテナランタイムに脆弱性がある場合、潜在的にホストシステムにエスケープする可能性があります。
    - **ファイルシステムアクセス:** rootコンテナはすべてのファイルとディレクトリにアクセスでき、潜在的に機密ホストデータを露出させる可能性があります。
    - **ネットワークアクセス:** rootコンテナは特権ポートにバインドでき、潜在的にホストネットワーキングに干渉する可能性があります。
    - **リソース乱用:** rootコンテナは適切な制限なしに過剰なシステムリソースを消費できます。
- **Copilotのガイダンス:**
    - Dockerfile内でnon-root `USER`の定義を常に推奨します。アプリケーション専用ユーザーを作成します。
    - non-rootユーザーがアプリケーションを実行するために必要最小限の権限を持つことを確保します。
    - 後続の操作がnon-rootユーザーで実行されることを確保するため、Dockerfileの早期で`USER`ディレクティブを使用します。
    - 利用可能な場合、ユーザー名前空間やその他のセキュリティ機能の使用を検討します。
- **例（セキュアユーザー作成）:**
```dockerfile
# 専用ユーザーとグループを作成
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

# アプリケーションファイルの適切な所有権を設定
RUN chown -R appuser:appgroup /app

# non-rootユーザーに切り替え
USER appuser

# ユーザーが必要なディレクトリに書き込めることを確保
VOLUME ["/app/data"]
```

### **2. 最小ベースイメージ**
- **原則:** 小さなイメージはより少ないパッケージを意味し、したがってより少ない脆弱性と縮小された攻撃面を意味します。
- **詳細分析:**
    - **攻撃面縮小:** ベースイメージの各パッケージは潜在的脆弱性を表します。より少ないパッケージはより少ない潜在的攻撃ベクターを意味します。
    - **更新頻度:** 最小イメージはより頻繁に更新され、脆弱性露出ウィンドウが短くなります。
    - **リソース効率:** 小さなイメージはより少ないストレージとネットワーク帯域幅を消費します。
    - **ビルド速度:** 小さなベースイメージはより高速にビルドされ、脆弱性スキャンも容易です。
- **Copilotのガイダンス:**
    - 可能な場合、フルディストリビューションよりも`alpine`、`slim`、または`distroless`イメージを優先します。
    - セキュリティスキャニングツールを使用してベースイメージの脆弱性を定期的に見直します。
    - セキュリティパッチのため言語固有の最小イメージ（例：`openjdk:17`の代わりに`openjdk:17-jre-slim`）の使用を検討します。
    - セキュリティパッチのため最新の最小ベースイメージバージョンで更新を続けます。
- **例（最小ベースイメージ選択）:**
```dockerfile
# 悪い例: 多くの不要なパッケージを持つフルディストリビューション
FROM ubuntu:20.04

# 良い例: 最小Alpineベースイメージ
FROM node:18-alpine

# さらに良い例: 最大セキュリティのためのDistrolessイメージ
FROM gcr.io/distroless/nodejs18-debian11
```

### **3. Dockerfileの静的解析セキュリティテスト（SAST）**
- **原則:** イメージをビルドする前に、Dockerfileのセキュリティ設定ミスと既知の脆弱性をスキャンします。
- **詳細分析:**
    - **Dockerfile Linting:** `hadolint`のようなツールを使用してDockerfileのベストプラクティスとセキュリティ問題をチェックします。
    - **ベースイメージスキャニング:** ベースイメージを使用する前に既知の脆弱性をスキャンします。
    - **CI/CD統合:** セキュリティスキャニングをCI/CDパイプラインに統合して早期に問題を検出します。
    - **ポリシー強制:** セキュリティポリシーを定義し、自動スキャニングを通してそれらを強制します。
- **Copilotのガイダンス:**
    - `hadolint`（Dockerfile linting用）や`Trivy`、`Clair`、または`Snyk Container`（イメージ脆弱性スキャニング用）などのツールをCIパイプラインに統合することを推奨します。
    - Dockerfileとビルドされたイメージの両方の自動スキャニングの設定を提案します。
    - ベースイメージで重大な脆弱性が見つかった場合のビルド失敗を推奨します。
    - 新しく発見された脆弱性のためのレジストリ内イメージの定期的スキャニングをアドバイスします。
- **例（CIでのセキュリティスキャニング）:**
```yaml
# GitHub Actionsの例
- name: Run Hadolint
  run: |
    docker run --rm -i hadolint/hadolint < Dockerfile

- name: Scan image for vulnerabilities
  run: |
    docker build -t myapp .
    trivy image myapp
```

### **4. イメージ署名と検証**
- **原則:** イメージが改ざんされておらず、信頼できるソースからのものであることを確保します。
- **詳細分析:**
    - **暗号化署名:** デジタル署名を使用してコンテナイメージの真正性と完全性を検証します。
    - **信頼ポリシー:** 環境で実行を許可するイメージを指定する信頼ポリシーを定義します。
    - **サプライチェーンセキュリティ:** イメージ署名はソフトウェアサプライチェーンの保護の重要な要素です。
    - **コンプライアンス:** 多くのコンプライアンスフレームワークでは実稼働デプロイメントにイメージ署名が必要です。
- **Copilotのガイダンス:**
    - 実稼働環境でイメージの署名と検証にNotaryまたはDocker Content Trustの使用を提案します。
    - すべての実稼働イメージのCI/CDパイプラインでイメージ署名の実装を推奨します。
    - 未署名イメージの実行を防ぐ信頼ポリシーの設定をアドバイスします。
    - より高度な署名機能のためCosignのような新しいツールの使用を検討します。
- **例（Cosignでのイメージ署名）:**
```bash
# イメージに署名
cosign sign -key cosign.key myregistry.com/myapp:v1.0.0

# イメージを検証
cosign verify -key cosign.pub myregistry.com/myapp:v1.0.0
```

### **5. 権限制限と読み取り専用ファイルシステム**
- **原則:** コンテナの権限を制限し、可能な場合は読み取り専用アクセスを確保して攻撃面を最小化します。
- **詳細分析:**
    - **Linux Capabilities:** コンテナが機能するために不要な不必要なLinux capabilityを削除します。
    - **読み取り専用ルート:** 可能な場合はrootファイルシステムを読み取り専用でマウントしてランタイム変更を防ぎます。
    - **Seccompプロファイル:** seccompプロファイルを使用してコンテナが実行できるシステムコールを制限します。
    - **AppArmor/SELinux:** セキュリティモジュールを使用して追加のアクセス制御を強制します。
- **Copilotのガイダンス:**
    - 不要なcapability（例：`NET_RAW`、`SYS_ADMIN`）を削除するため`CAP_DROP`の使用を検討します。
    - 機密データと設定ファイルに読み取り専用ボリュームのマウントを推奨します。
    - コンテナランタイムで利用可能な場合はセキュリティプロファイルとポリシーの使用を提案します。
    - 複数のセキュリティ制御による多層防御の実装をアドバイスします。
- **例（権限制限）:**
```dockerfile
# 不要なcapabilityを削除
RUN setcap -r /usr/bin/node

# または docker run でセキュリティオプションを使用
# docker run --cap-drop=ALL --security-opt=no-new-privileges myapp
```

### **6. イメージレイヤーに機密データなし**
- **原則:** シークレット、秘密鍵、資格情報はイメージレイヤーの一部となるため、イメージレイヤーに含めません。
- **詳細分析:**
    - **レイヤー履歴:** イメージに追加されたすべてのファイルはイメージ履歴に保存され、後のレイヤーで削除されても抽出可能です。
    - **ビルド引数:** `--build-arg`はビルド中にデータを渡すことができますが、この方法で機密情報を渡すことは避けます。
    - **ランタイムシークレット:** シークレット管理ソリューションを使用してランタイムで機密データを注入します。
    - **イメージスキャニング:** 定期的なイメージスキャニングで偶然に含まれたシークレットを検出できます。
- **Copilotのガイダンス:**
    - ビルド中の一時的シークレットにビルド引数（`--build-arg`）を使用します（ただし機密情報を直接渡すことは避けます）。
    - ランタイムにシークレット管理ソリューション（Kubernetes Secrets、Docker Secrets、HashiCorp Vault）を使用します。
    - イメージに偶然に含まれたシークレットをスキャンすることを推奨します。
    - 最終イメージにビルド時シークレットを含めることを避けるマルチステージビルドの使用を提案します。
- **アンチパターン:** `ADD secrets.txt /app/secrets.txt`
- **例（セキュアシークレット管理）:**
```dockerfile
# 悪い例: 絶対にこれをしない
# COPY secrets.txt /app/secrets.txt

# 良い例: ランタイムシークレットを使用
# アプリケーションは環境変数またはマウントされたファイルからシークレットを読み取るべき
CMD ["node", "dist/main.js"]
```

### **7. ヘルスチェック（生存性とレディネスプローブ）**
- **原則:** 適切なヘルスチェックを実装してコンテナが実行中でトラフィック配信の準備ができていることを確保します。
- **詳細分析:**
    - **生存性プローブ:** アプリケーションが生存してリクエストに応答しているかチェックします。失敗した場合はコンテナを再起動します。
    - **レディネスプローブ:** アプリケーションがトラフィックを受け取る準備ができているかチェックします。失敗した場合はロードバランサーから削除します。
    - **ヘルスチェック設計:** 軽量で高速で、アプリケーションの健全性を正確に反映するヘルスチェックを設計します。
    - **オーケストレーション統合:** ヘルスチェックはKubernetesのようなオーケストレーションシステムがコンテナライフサイクルを管理するために重要です。
- **Copilotのガイダンス:**
    - Dockerfile内で`HEALTHCHECK`命令を定義します。これらはKubernetesのようなオーケストレーションシステムにとって重要です。
    - アプリケーション固有で実際の機能をチェックするヘルスチェックを設計します。
    - 応答性とオーバーヘッドのバランスを取るため、ヘルスチェックに適切な間隔とタイムアウトを使用します。
    - 複雑なアプリケーションには生存性とレディネスチェックの両方の実装を検討します。
- **例（包括的ヘルスチェック）:**
```dockerfile
# アプリケーションが応答していることを確認するヘルスチェック
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl --fail http://localhost:8080/health || exit 1

# 代替: アプリケーション固有のヘルスチェックを使用
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js || exit 1
```

## コンテナランタイムとオーケストレーションベストプラクティス

### **1. リソース制限**
- **原則:** CPUとメモリを制限してリソース枯渇と騒がしい隣人を防ぎます。
- **詳細分析:**
    - **CPU制限:** CPU制限を設定してコンテナが過剰なCPU時間を消費し他のコンテナに影響することを防ぎます。
    - **メモリ制限:** メモリ制限を設定してコンテナがすべての利用可能メモリを消費しシステム不安定性を引き起こすことを防ぎます。
    - **リソース要求:** リソース要求を設定してコンテナに最小リソースへの保証されたアクセスを確保します。
    - **監視:** リソース使用量を監視して制限が適切で制限が厳しすぎないことを確保します。
- **Copilotのガイダンス:**
    - Docker ComposeまたはKubernetesリソース要求/制限で`cpu_limits`、`memory_limits`の設定を常に推奨します。
    - 制限を適切に調整するためリソース使用量の監視を提案します。
    - 予測可能なリソース割り当てのため要求と制限の両方の設定を推奨します。
    - クラスター全体のリソース使用量を管理するためKubernetesでのリソースクォータの使用をアドバイスします。
- **例（Docker Composeリソース制限）:**
```yaml
services:
  app:
    image: myapp:latest
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
```

### **2. ログとモニタリング**
- **原則:** 可観測性とトラブルシューティングのためコンテナログとメトリクスを収集し中央化します。
- **詳細分析:**
    - **構造化ログ:** より良い解析と分析のため構造化ログ（JSON）を使用します。
    - **ログ集約:** 検索、分析、アラートのためすべてのコンテナからのログを中央化します。
    - **メトリクス収集:** パフォーマンス監視のためアプリケーションとシステムメトリクスを収集します。
    - **分散トレーシング:** サービス間のリクエストフローを理解するため分散トレーシングを実装します。
- **Copilotのガイダンス:**
    - コンテナログに標準ログ出力（`STDOUT`/`STDERR`）を使用します。
    - ログアグリゲーター（Fluentd、Logstash、Loki）と監視ツール（Prometheus、Grafana）との統合を推奨します。
    - より良い可観測性のためアプリケーションでの構造化ログの実装を推奨します。
    - ストレージコストを管理するためログローテーションと保持ポリシーの設定を提案します。
- **例（構造化ログ）:**
```javascript
// アプリケーションログ
const winston = require('winston');
const logger = winston.createLogger({
  format: winston.format.json(),
  transports: [new winston.transports.Console()]
});
```

### **3. 永続ストレージ**
- **原則:** ステートフルアプリケーションでは、コンテナ再起動間でデータを維持するため永続ボリュームを使用します。
- **詳細分析:**
    - **ボリュームタイプ:** 要件に応じて名前付きボリューム、バインドマウント、またはクラウドストレージを使用します。
    - **データ永続性:** コンテナ再起動、更新、移行間でデータが永続することを確保します。
    - **バックアップ戦略:** データ損失を防ぐため永続データのバックアップ戦略を実装します。
    - **パフォーマンス:** パフォーマンス要件を満たすストレージソリューションを選択します。
- **Copilotのガイダンス:**
    - コンテナライフサイクルを超えて永続する必要があるデータにはDocker VolumesまたはKubernetes Persistent Volumesを使用します。
    - コンテナの書き込み可能レイヤー内に永続データを保存しません。
    - 永続データのバックアップと災害復旧手順の実装を推奨します。
    - より良いスケーラビリティと信頼性のためクラウドネイティブストレージソリューションの使用を提案します。
- **例（Dockerボリューム使用）:**
```yaml
services:
  database:
    image: postgres:13
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD_FILE: /run/secrets/db_password

volumes:
  postgres_data:
```

### **4. ネットワーキング**
- **原則:** コンテナ間のセキュアで分離された通信のため定義されたコンテナネットワークを使用します。
- **詳細分析:**
    - **ネットワーク分離:** 異なるアプリケーション層や環境に別々のネットワークを作成します。
    - **サービス発見:** 自動サービス発見のためコンテナオーケストレーション機能を使用します。
    - **ネットワークポリシー:** コンテナ間のトラフィックを制御するためネットワークポリシーを実装します。
    - **ロードバランシング:** 複数のコンテナインスタンス間でトラフィックを分散するためロードバランサーを使用します。
- **Copilotのガイダンス:**
    - サービス分離とセキュリティのためカスタムDockerネットワークを作成します。
    - pod間通信を制御するためKubernetesでネットワークポリシーを定義します。
    - オーケストレーションプラットフォームが提供するサービス発見メカニズムを使用します。
    - 多層アプリケーションに適切なネットワークセグメンテーションを実装します。
- **例（Dockerネットワーク設定）:**
```yaml
services:
  web:
    image: nginx
    networks:
      - frontend
      - backend

  api:
    image: myapi
    networks:
      - backend

networks:
  frontend:
  backend:
    internal: true
```

### **5. オーケストレーション（Kubernetes、Docker Swarm）**
- **原則:** 大規模コンテナ化アプリケーションの管理にオーケストレーターを使用します。
- **詳細分析:**
    - **スケーリング:** 需要とリソース使用量に基づいてアプリケーションを自動的にスケールします。
    - **自己修復:** 失敗したコンテナを自動的に再起動し、健全でないインスタンスを置き換えます。
    - **サービス発見:** 内蔵サービス発見とロードバランシングを提供します。
    - **ローリング更新:** 自動ロールバック機能によるゼロダウンタイム更新を実行します。
- **Copilotのガイダンス:**
    - 複雑で大規模なデプロイメントに高度な要件があるKubernetesを推奨します。
    - スケーリング、自己修復、サービス発見のためオーケストレーター機能を活用します。
    - ゼロダウンタイムデプロイメントのためローリング更新戦略を使用します。
    - オーケストレーション環境での適切なリソース管理と監視を実装します。
- **例（Kubernetesデプロイメント）:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        resources:
          requests:
            memory: "64Mi"
            cpu: "250m"
          limits:
            memory: "128Mi"
            cpu: "500m"
```

## Dockerfileレビューチェックリスト

- [ ] 該当する場合マルチステージビルドが使用されているか（コンパイル言語、重いビルドツール）？
- [ ] 最小で特定のベースイメージが使用されているか（例：`alpine`、`slim`、バージョン指定）？
- [ ] レイヤーが最適化されているか（`RUN`コマンドの結合、同一レイヤーでのクリーンアップ）？
- [ ] `.dockerignore`ファイルが存在し包括的か？
- [ ] `COPY`命令が特定で最小か？
- [ ] 実行中のアプリケーションにnon-root `USER`が定義されているか？
- [ ] ドキュメントのため`EXPOSE`命令が使用されているか？
- [ ] `CMD`や`ENTRYPOINT`が正しく使用されているか？
- [ ] 機密設定が環境変数で処理されているか（ハードコードされていない）？
- [ ] `HEALTHCHECK`命令が定義されているか？
- [ ] シークレットや機密データがイメージレイヤーに偶然含まれていないか？
- [ ] 静的解析ツール（Hadolint、Trivy）がCIに統合されているか？

## Dockerビルドとランタイムのトラブルシューティング

### **1. 大きなイメージサイズ**
- 不要なファイルのレイヤーを確認します。`docker history <image>`を使用します。
- マルチステージビルドを実装します。
- より小さなベースイメージを使用します。
- `RUN`コマンドを最適化し一時ファイルをクリーンアップします。

### **2. 遅いビルド**
- 最も頻繁でない変更から最も頻繁な変更の順に命令を並べてビルドキャッシュを活用します。
- `.dockerignore`を使用して無関係なファイルを除外します。
- キャッシュ問題のトラブルシューティングに`docker build --no-cache`を使用します。

### **3. コンテナが開始しない/クラッシュする**
- `CMD`と`ENTRYPOINT`命令を確認します。
- コンテナログを確認します（`docker logs <container_id>`）。
- 最終イメージにすべての依存関係が存在することを確認します。
- リソース制限を確認します。

### **4. コンテナ内の権限問題**
- イメージ内のファイル/ディレクトリ権限を確認します。
- `USER`が操作に必要な権限を持っていることを確認します。
- マウントされたボリュームの権限を確認します。

### **5. ネットワーク接続問題**
- 公開ポート（`EXPOSE`）と公開ポート（`docker run`の`-p`）を確認します。
- コンテナネットワーク設定を確認します。
- ファイアウォールルールを確認します。

## 結論

DockerによるEffectiveなコンテナ化は現代のDevOpsの基盤です。Dockerfile作成、イメージ最適化、セキュリティ、ランタイム管理のこれらのベストプラクティスに従うことで、開発者に高効率で安全、可搬性のあるアプリケーションの構築を導くことができます。アプリケーションの進化に合わせてコンテナ戦略を継続的に評価し改善することを忘れないでください。

---

<!-- コンテナ化とDockerベストプラクティス指示書の終わり -->
