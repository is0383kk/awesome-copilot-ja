---
mode: 'agent'
tools: ['changes', 'codebase', 'editFiles', 'problems', 'runCommands']
description: 'Entity Framework Core のベストプラクティスを取得します'
---

# Entity Framework Core ベストプラクティス

Entity Framework Core を使用する際のベストプラクティスに従うことをサポートします。

## データコンテキストの設計

- DbContext クラスを集中的で一貫性のあるものに保つ
- 設定オプションにはコンストラクターインジェクションを使用する
- Fluent API 設定には OnModelCreating をオーバーライドする
- IEntityTypeConfiguration を使用してエンティティ設定を分離する
- コンソールアプリやテストには DbContextFactory パターンの使用を検討する

## エンティティの設計

- 意味のある主キーを使用する（自然キー vs 代理キーを検討）
- 適切な関係を実装する（1対1、1対多、多対多）
- 制約と検証にはデータアノテーションまたは Fluent API を使用する
- 適切なナビゲーションプロパティを実装する
- 値オブジェクトには所有エンティティタイプの使用を検討する

## パフォーマンス

- 読み取り専用クエリには AsNoTracking() を使用する
- 大きな結果セットには Skip() と Take() を使ってページネーションを実装する
- 必要な場合は Include() を使用して関連エンティティを Eager Load する
- 必要なフィールドのみを取得するプロジェクション（Select）を検討する
- 頻繁に実行されるクエリにはコンパイル済みクエリを使用する
- 関連データを適切にインクルードして N+1 クエリ問題を回避する

## マイグレーション

- 小さく、集中的なマイグレーションを作成する
- マイグレーションに説明的な名前を付ける
- 本番環境への適用前にマイグレーション SQL スクリプトを検証する
- デプロイメントにはマイグレーションバンドルの使用を検討する
- 適切な場合はマイグレーションを通じてデータシーディングを追加する

## クエリ

- IQueryable を慎重に使用し、クエリがいつ実行されるかを理解する
- 生の SQL よりも強い型付けの LINQ クエリを優先する
- 適切なクエリオペレーター（Where、OrderBy、GroupBy）を使用する
- 複雑な操作にはデータベース関数を検討する
- 再利用可能なクエリには仕様パターンを実装する

## 変更追跡と保存

- 適切な変更追跡戦略を使用する
- SaveChanges() 呼び出しをバッチ処理する
- マルチユーザーシナリオでは並行性制御を実装する
- 複数の操作にはトランザクションの使用を検討する
- 適切な DbContext の有効期間を使用する（Web アプリにはスコープ付き）

## セキュリティ

- パラメーター化クエリを使用して SQL インジェクションを回避する
- 適切なデータアクセス権限を実装する
- 生の SQL クエリには注意する
- 機密情報にはデータ暗号化を検討する
- マイグレーションを使用してデータベースユーザー権限を管理する

## テスト

- 単体テストにはインメモリデータベースプロバイダーを使用する
- 統合テストには SQLite を使用した別個のテストコンテキストを作成する
- 純粋な単体テストには DbContext と DbSet をモックする
- 分離された環境でマイグレーションをテストする
- モデル変更にはスナップショットテストを検討する

私の EF Core コードをレビューする際は、これらのベストプラクティスに従った問題の特定と改善提案を行ってください。