---
description: 'コードベースを分析して詳細なアーキテクチャドキュメントを作成する包括的なプロジェクトアーキテクチャ設計図ジェネレーター。テクノロジースタックとアーキテクチャパターンを自動検出し、ビジュアル図を生成し、実装パターンを文書化し、アーキテクチャの一貫性維持と新規開発のガイドを提供する拡張可能な設計図を提供します。'
mode: 'agent'
---

# 包括的プロジェクトアーキテクチャ設計図ジェネレーター

## 設定変数
${PROJECT_TYPE="Auto-detect|.NET|Java|React|Angular|Python|Node.js|Flutter|Other"} <!-- 主要技術 -->
${ARCHITECTURE_PATTERN="Auto-detect|Clean Architecture|Microservices|Layered|MVVM|MVC|Hexagonal|Event-Driven|Serverless|Monolithic|Other"} <!-- 主要アーキテクチャパターン -->
${DIAGRAM_TYPE="C4|UML|Flow|Component|None"} <!-- アーキテクチャ図の種類 -->
${DETAIL_LEVEL="High-level|Detailed|Comprehensive|Implementation-Ready"} <!-- 含める詳細レベル -->
${INCLUDES_CODE_EXAMPLES=true|false} <!-- パターンを説明するサンプルコードを含める -->
${INCLUDES_IMPLEMENTATION_PATTERNS=true|false} <!-- 詳細な実装パターンを含める -->
${INCLUDES_DECISION_RECORDS=true|false} <!-- アーキテクチャ決定記録を含める -->
${FOCUS_ON_EXTENSIBILITY=true|false} <!-- 拡張ポイントとパターンを強調 -->

## 生成プロンプト

"アーキテクチャの一貫性維持のための決定的な参考資料として機能するよう、コードベース内のアーキテクチャパターンを徹底的に分析する包括的な'Project_Architecture_Blueprint.md'ドキュメントを作成してください。以下のアプローチを使用してください：

### 1. アーキテクチャ検出・分析
- ${PROJECT_TYPE == "Auto-detect" ? "プロジェクト構造を分析して、以下を調査することですべての技術スタックとフレームワークを特定する：
  - プロジェクトファイルと設定ファイル
  - パッケージ依存関係とインポート文
  - フレームワーク固有のパターンと規約
  - ビルドとデプロイ設定" : "${PROJECT_TYPE}固有のパターンと実践に焦点を当てる"}
  
- ${ARCHITECTURE_PATTERN == "Auto-detect" ? "以下を分析してアーキテクチャパターンを決定する：
  - フォルダ構成と名前空間
  - 依存関係フローとコンポーネント境界
  - インターフェース分離と抽象化パターン
  - コンポーネント間の通信メカニズム" : "${ARCHITECTURE_PATTERN}アーキテクチャがどのように実装されているかを文書化する"}

### 2. アーキテクチャ概要
- 全体的なアーキテクチャアプローチの明確で簡潔な説明を提供
- アーキテクチャ選択において明らかな指針となる原則を文書化
- アーキテクチャ境界とその強制方法を特定
- ハイブリッドアーキテクチャパターンや標準パターンの適応を記録

### 3. アーキテクチャ可視化
${DIAGRAM_TYPE != "None" ? `複数の抽象化レベルで${DIAGRAM_TYPE}図を作成：
- 主要サブシステムを示すハイレベルアーキテクチャ概要
- 関係と依存関係を示すコンポーネント相互作用図
- システム内での情報移動を示すデータフロー図
- 図が理論的パターンではなく実際の実装を正確に反映することを確認` : "実際のコード依存関係に基づいたコンポーネント関係を記述し、以下の明確なテキスト説明を提供：
- サブシステム構成と境界
- 依存関係方向とコンポーネント相互作用
- データフローとプロセスシーケンス"}

### 4. 主要アーキテクチャコンポーネント
コードベースで発見された各アーキテクチャコンポーネントについて：

- **目的と責任**：
  - アーキテクチャ内での主要機能
  - 対処されるビジネスドメインや技術的関心事
  - 境界とスコープの制限

- **内部構造**：
  - コンポーネント内のクラス/モジュールの構成
  - 主要な抽象化とその実装
  - 使用される設計パターン

- **相互作用パターン**：
  - コンポーネントが他と通信する方法
  - 公開・消費されるインターフェース
  - 依存性注入パターン
  - イベント発行/購読メカニズム

- **進化パターン**：
  - コンポーネントを拡張する方法
  - バリエーションポイントとプラグインメカニズム
  - 設定とカスタマイゼーションアプローチ

### 5. アーキテクチャ層と依存関係
- コードベースで実装されている層構造をマッピング
- 層間の依存関係ルールを文書化
- 層分離を可能にする抽象化メカニズムを特定
- 循環依存関係や層違反を記録
- 分離を維持するために使用される依存性注入パターンを文書化

### 6. データアーキテクチャ
- ドメインモデル構造と構成を文書化
- エンティティ関係と集約パターンをマッピング
- データアクセスパターン（リポジトリ、データマッパーなど）を特定
- データ変換とマッピングアプローチを文書化
- キャッシュ戦略と実装を記録
- データ検証パターンを文書化

### 7. 横断的関心事の実装
横断的関心事の実装パターンを文書化：

- **認証・認可**：
  - セキュリティモデル実装
  - 権限強制パターン
  - アイデンティティ管理アプローチ
  - セキュリティ境界パターン

- **エラー処理・回復力**：
  - 例外処理パターン
  - 再試行とサーキットブレーカー実装
  - フォールバックと優雅な劣化戦略
  - エラー報告と監視アプローチ

- **ログ・監視**：
  - 計装パターン
  - 可観測性実装
  - 診断情報フロー
  - パフォーマンス監視アプローチ

- **検証**：
  - 入力検証戦略
  - ビジネスルール検証実装
  - 検証責任分散
  - エラー報告パターン

- **設定管理**：
  - 設定ソースパターン
  - 環境固有設定戦略
  - 秘密管理アプローチ
  - フィーチャーフラグ実装

### 8. サービス通信パターン
- サービス境界定義を文書化
- 通信プロトコルと形式を特定
- 同期対非同期通信パターンをマッピング
- APIバージョニング戦略を文書化
- サービス発見メカニズムを特定
- サービス通信における回復力パターンを記録

### 9. 技術固有アーキテクチャパターン
${PROJECT_TYPE == "Auto-detect" ? "検出された各技術スタックについて、固有のアーキテクチャパターンを文書化：" : `${PROJECT_TYPE}固有のアーキテクチャパターンを文書化：`}

${(PROJECT_TYPE == ".NET" || PROJECT_TYPE == "Auto-detect") ? 
"#### .NETアーキテクチャパターン（検出された場合）
- ホストとアプリケーションモデル実装
- ミドルウェアパイプライン構成
- フレームワークサービス統合パターン
- ORMとデータアクセスアプローチ
- API実装パターン（コントローラー、ミニマルAPIなど）
- 依存性注入コンテナ設定" : ""}

${(PROJECT_TYPE == "Java" || PROJECT_TYPE == "Auto-detect") ? 
"#### Javaアーキテクチャパターン（検出された場合）
- アプリケーションコンテナとブートストラッププロセス
- 依存性注入フレームワーク使用（Spring、CDIなど）
- AOP実装パターン
- トランザクション境界管理
- ORM設定と使用パターン
- サービス実装パターン" : ""}

${(PROJECT_TYPE == "React" || PROJECT_TYPE == "Auto-detect") ? 
"#### Reactアーキテクチャパターン（検出された場合）
- コンポーネント構成と再利用戦略
- 状態管理アーキテクチャ
- 副作用処理パターン
- ルーティングとナビゲーションアプローチ
- データ取得とキャッシュパターン
- レンダリング最適化戦略" : ""}

${(PROJECT_TYPE == "Angular" || PROJECT_TYPE == "Auto-detect") ? 
"#### Angularアーキテクチャパターン（検出された場合）
- モジュール構成戦略
- コンポーネント階層設計
- サービスと依存性注入パターン
- 状態管理アプローチ
- リアクティブプログラミングパターン
- ルートガード実装" : ""}

${(PROJECT_TYPE == "Python" || PROJECT_TYPE == "Auto-detect") ? 
"#### Pythonアーキテクチャパターン（検出された場合）
- モジュール構成アプローチ
- 依存関係管理戦略
- OOP対関数型実装パターン
- フレームワーク統合パターン
- 非同期プログラミングアプローチ" : ""}

### 10. 実装パターン
${INCLUDES_IMPLEMENTATION_PATTERNS ? 
"主要なアーキテクチャコンポーネントの具体的な実装パターンを文書化：

- **インターフェース設計パターン**：
  - インターフェース分離アプローチ
  - 抽象化レベル決定
  - 汎用対特定インターフェースパターン
  - デフォルト実装パターン

- **サービス実装パターン**：
  - サービス生存期間管理
  - サービス構成パターン
  - 操作実装テンプレート
  - サービス内エラー処理

- **リポジトリ実装パターン**：
  - クエリパターン実装
  - トランザクション管理
  - 並行性処理
  - 一括操作パターン

- **コントローラー/API実装パターン**：
  - リクエスト処理パターン
  - レスポンス形式化アプローチ
  - パラメーター検証
  - APIバージョニング実装

- **ドメインモデル実装**：
  - エンティティ実装パターン
  - 値オブジェクトパターン
  - ドメインイベント実装
  - ビジネスルール強制" : "詳細な実装パターンはコードベース全体で異なることを言及。"}

### 11. テストアーキテクチャ
- アーキテクチャと整合したテスト戦略を文書化
- テスト境界パターン（単体、統合、システム）を特定
- テストダブルとモッキングアプローチをマッピング
- テストデータ戦略を文書化
- テストツールとフレームワーク統合を記録

### 12. デプロイアーキテクチャ
- 設定から派生したデプロイトポロジーを文書化
- 環境固有のアーキテクチャ適応を特定
- ランタイム依存関係解決パターンをマッピング
- 環境間の設定管理を文書化
- コンテナ化とオーケストレーションアプローチを特定
- クラウドサービス統合パターンを記録

### 13. 拡張・進化パターン
${FOCUS_ON_EXTENSIBILITY ? 
"アーキテクチャを拡張するための詳細なガイダンスを提供：

- **機能追加パターン**：
  - アーキテクチャ整合性を保持しながら新機能を追加する方法
  - タイプ別の新コンポーネント配置場所
  - 依存関係導入ガイドライン
  - 設定拡張パターン

- **変更パターン**：
  - 既存コンポーネントを安全に変更する方法
  - 後方互換性維持戦略
  - 非推奨パターン
  - 移行アプローチ

- **統合パターン**：
  - 新しい外部システムを統合する方法
  - アダプター実装パターン
  - 汚職防止層パターン
  - サービスファサード実装" : "アーキテクチャの主要な拡張ポイントを文書化。"}

${INCLUDES_CODE_EXAMPLES ? 
"### 14. アーキテクチャパターン例
主要なアーキテクチャパターンを説明する代表的なコード例を抽出：

- **層分離例**：
  - インターフェース定義と実装分離
  - 層間通信パターン
  - 依存性注入例

- **コンポーネント通信例**：
  - サービス呼び出しパターン
  - イベント発行と処理
  - メッセージパッシング実装

- **拡張ポイント例**：
  - プラグイン登録と発見
  - 拡張インターフェース実装
  - 設定駆動拡張パターン

各例にパターンを明確に示すのに十分な文脈を含めるが、例は簡潔でアーキテクチャ概念に焦点を当てたものにする。" : ""}

${INCLUDES_DECISION_RECORDS ? 
"### 15. アーキテクチャ決定記録
コードベースで明らかな主要アーキテクチャ決定を文書化：

- **アーキテクチャスタイル決定**：
  - なぜ現在のアーキテクチャパターンが選択されたか
  - 検討された代替案（コード進化に基づく）
  - 決定に影響した制約

- **技術選択決定**：
  - 主要な技術選択とそのアーキテクチャへの影響
  - フレームワーク選択根拠
  - カスタム対既製コンポーネント決定

- **実装アプローチ決定**：
  - 選択された特定の実装パターン
  - 標準パターン適応
  - パフォーマンス対保守性トレードオフ

各決定について以下を記録：
- 決定を必要とした文脈
- 決定時に考慮された要因
- 結果として生じた結果（正と負）
- 導入された将来の柔軟性または制限" : ""}

### ${INCLUDES_DECISION_RECORDS ? "16" : INCLUDES_CODE_EXAMPLES ? "15" : "14"}. アーキテクチャガバナンス
- アーキテクチャ一貫性がどのように維持されるかを文書化
- アーキテクチャ準拠の自動チェックを特定
- コードベースで明らかなアーキテクチャレビュープロセスを記録
- アーキテクチャドキュメント実践を文書化

### ${INCLUDES_DECISION_RECORDS ? "17" : INCLUDES_CODE_EXAMPLES ? "16" : "15"}. 新規開発のための設計図
新機能実装のための明確なアーキテクチャガイドを作成：

- **開発ワークフロー**：
  - 異なる機能タイプの開始点
  - コンポーネント作成順序
  - 既存アーキテクチャとの統合ステップ
  - アーキテクチャ層別テストアプローチ

- **実装テンプレート**：
  - 主要アーキテクチャコンポーネントの基底クラス/インターフェーステンプレート
  - 新コンポーネントの標準ファイル構成
  - 依存関係宣言パターン
  - ドキュメント要件

- **よくある落とし穴**：
  - 避けるべきアーキテクチャ違反
  - よくあるアーキテクチャミス
  - パフォーマンス考慮事項
  - テストの盲点

この設計図がいつ生成されたかの情報と、アーキテクチャが進化するにつれてそれを最新に保つための推奨事項を含める。"