---

description: 'エンドツーエンドアプリケーションワークフローを文書化する包括的な技術非依存プロンプトジェネレーター。プロジェクトアーキテクチャパターン、技術スタック、データフローパターンを自動検出し、エントリーポイント、サービス層、データアクセス、エラーハンドリング、.NET、Java/Spring、React、マイクロサービスアーキテクチャを含む複数技術でのテストアプローチを網羅した詳細実装ブループリントを生成。'

mode: 'agent'
---
# プロジェクトワークフロー文書化ジェネレーター

## 設定変数

```
${PROJECT_TYPE="自動検出|.NET|Java|Spring|Node.js|Python|React|Angular|マイクロサービス|その他"}
<!-- 主要な技術スタック -->

${ENTRY_POINT="API|GraphQL|フロントエンド|CLI|メッセージコンシューマー|スケジュール済みジョブ|カスタム"}
<!-- フローの開始点 -->

${PERSISTENCE_TYPE="自動検出|SQLデータベース|NoSQLデータベース|ファイルシステム|外部API|メッセージキュー|キャッシュ|なし"}
<!-- データストレージタイプ -->

${ARCHITECTURE_PATTERN="自動検出|レイヤード|クリーン|CQRS|マイクロサービス|MVC|MVVM|サーバーレス|イベント駆動|その他"}
<!-- 主要なアーキテクチャパターン -->

${WORKFLOW_COUNT=1-5}
<!-- 文書化するワークフロー数 -->

${DETAIL_LEVEL="標準|実装準備完了"}
<!-- 含める実装詳細レベル -->

${INCLUDE_SEQUENCE_DIAGRAM=true|false}
<!-- シーケンス図を生成 -->

${INCLUDE_TEST_PATTERNS=true|false}
<!-- テストアプローチを含める -->
```

## 生成されたプロンプト

```
"コードベースを分析し、類似機能の実装テンプレートとして使用できる代表的なエンドツーエンドワークフローを${WORKFLOW_COUNT}個文書化してください。次のアプローチを使用してください:
```

### 初期検出フェーズ

```
${PROJECT_TYPE == "自動検出" ? 
  "まず、コードベース構造を調査して技術を特定します:
   - .NETソリューション/プロジェクト、Spring設定、Node.js/Expressファイルなどを確認
   - 使用されている主なプログラミング言語とフレームワークを特定
   - フォルダー構造と主要コンポーネントに基づいてアーキテクチャパターンを決定" 
  : "${PROJECT_TYPE}パターンと慣習に焦点を当てる"}
```

```
${ENTRY_POINT == "自動検出" ? 
  "典型的なエントリーポイントを以下を探すことで特定します:
   - APIコントローラーやルート定義
   - GraphQLリゾルバー
   - ネットワークリクエストを開始するUIコンポーネント
   - メッセージハンドラーやイベントサブスクライバー
   - スケジュール済みジョブ定義" 
  : "${ENTRY_POINT}エントリーポイントに焦点を当てる"}
```

```
${PERSISTENCE_TYPE == "自動検出" ? 
  "永続化メカニズムを以下を調査して決定します:
   - データベースコンテキスト/接続設定
   - リポジトリ実装
   - ORMマッピング
   - 外部APIクライアント
   - ファイルシステムとのやり取り" 
  : "${PERSISTENCE_TYPE}とのやり取りに焦点を当てる"}
```

### ワークフロー文書化指示

システム内で最も代表的なワークフロー`${WORKFLOW_COUNT}`個について:

#### 1. ワークフロー概要
   - ワークフローの名前と簡単な説明を提供
   - それが提供するビジネス目的を説明
   - トリガーアクションやイベントを特定
   - 完全なワークフローに関与するすべてのファイル/クラスをリスト

#### 2. エントリーポイント実装

**APIエントリーポイント:**
```
${ENTRY_POINT == "API" || ENTRY_POINT == "自動検出" ? 
  "- リクエストを受信するAPIコントローラークラスとメソッドを文書化
   - 属性/アノテーションを含む完全なメソッドシグネチャを表示
   - 完全なリクエストDTO/モデルクラス定義を含める
   - バリデーション属性とカスタムバリデーターを文書化
   - 認証/認可属性とチェックを表示" : ""}
```

**GraphQLエントリーポイント:**
```
${ENTRY_POINT == "GraphQL" || ENTRY_POINT == "自動検出" ? 
  "- GraphQLリゾルバークラスとメソッドを文書化
   - クエリ/ミューテーション用の完全なスキーマ定義を表示
   - 入力型定義を含める
   - パラメーター処理を含むリゾルバーメソッド実装を表示" : ""}
```

**フロントエンドエントリーポイント:**
```
${ENTRY_POINT == "フロントエンド" || ENTRY_POINT == "自動検出" ? 
  "- API呼び出しを開始するコンポーネントを文書化
   - リクエストをトリガーするイベントハンドラーを表示
   - APIクライアントサービスメソッドを含める
   - リクエストに関連する状態管理コードを表示" : ""}
```

**メッセージコンシューマーエントリーポイント:**
```
${ENTRY_POINT == "メッセージコンシューマー" || ENTRY_POINT == "自動検出" ? 
  "- メッセージハンドラークラスとメソッドを文書化
   - メッセージサブスクリプション設定を表示
   - 完全なメッセージモデル定義を含める
   - デシリアライゼーションとバリデーションロジックを表示" : ""}
```

#### 3. サービス層実装
   - 依存関係を含む関与する各サービスクラスを文書化
   - パラメーターと戻り値の型を含む完全なメソッドシグネチャを表示
   - 主要なビジネスロジックを含む実際のメソッド実装を含める
   - 該当する場合はインターフェース定義を文書化
   - 依存性注入登録パターンを表示

**CQRSパターン:**
```
${ARCHITECTURE_PATTERN == "CQRS" || ARCHITECTURE_PATTERN == "自動検出" ? 
  "- 完全なコマンド/クエリハンドラー実装を含める" : ""}
```

**クリーンアーキテクチャパターン:**
```
${ARCHITECTURE_PATTERN == "クリーン" || ARCHITECTURE_PATTERN == "自動検出" ? 
  "- ユースケース/インタラクター実装を表示" : ""}
```

#### 4. データマッピングパターン
   - DTOからドメインモデルへのマッピングコードを文書化
   - オブジェクトマッパー設定や手動マッピングメソッドを表示
   - マッピング中のバリデーションロジックを含める
   - マッピング中に作成されるドメインイベントを文書化

#### 5. データアクセス実装
   - リポジトリインターフェースとその実装を文書化
   - パラメーターと戻り値の型を含む完全なメソッドシグネチャを表示
   - 実際のクエリ実装を含める
   - すべてのプロパティを含むエンティティ/モデルクラス定義を文書化
   - トランザクション処理パターンを表示

**SQLデータベースパターン:**
```
${PERSISTENCE_TYPE == "SQLデータベース" || PERSISTENCE_TYPE == "自動検出" ? 
  "- ORM設定、アノテーション、またはFluent API使用を含める
   - 実際のSQLクエリまたはORMステートメントを表示" : ""}
```

**NoSQLデータベースパターン:**
```
${PERSISTENCE_TYPE == "NoSQLデータベース" || PERSISTENCE_TYPE == "自動検出" ? 
  "- ドキュメント構造定義を表示
   - ドキュメントクエリ/更新操作を含める" : ""}
```

#### 6. レスポンス構築
   - レスポンスDTO/モデルクラス定義を文書化
   - ドメイン/エンティティモデルからレスポンスモデルへのマッピングを表示
   - ステータスコード選択ロジックを含める
   - エラーレスポンス構造と生成を文書化

#### 7. エラーハンドリングパターン
   - ワークフローで使用される例外タイプを文書化
   - 各層でのtry/catchパターンを表示
   - グローバル例外ハンドラー設定を含める
   - エラーログ実装を文書化
   - リトライポリシーやサーキットブレーカーパターンを表示
   - 失敗シナリオの補償アクションを含める

#### 8. 非同期処理パターン
   - バックグラウンドジョブスケジューリングコードを文書化
   - イベント公開実装を表示
   - メッセージキュー送信パターンを含める
   - コールバックやWebhook実装を文書化
   - 非同期操作の追跡と監視方法を表示

**テストアプローチ（オプション）:**
```
${INCLUDE_TEST_PATTERNS ? 
  "9. **テストアプローチ**
     - 各層の単体テスト実装を文書化
     - モックパターンとテストフィクスチャセットアップを表示
     - 統合テスト実装を含める
     - テストデータ生成アプローチを文書化
     - API/コントローラーテスト実装を表示" : ""}
```

**シーケンス図（オプション）:**
```
${INCLUDE_SEQUENCE_DIAGRAM ? 
  "10. **シーケンス図**
      - すべてのコンポーネントを表示する詳細なシーケンス図を生成
      - パラメーター型を含むメソッド呼び出しを含める
      - コンポーネント間の戻り値を表示
      - 条件フローとエラーパスを文書化" : ""}
```

#### 11. 命名規約
以下の一貫したパターンを文書化:
- コントローラー命名（例: `EntityNameController`）
- サービス命名（例: `EntityNameService`）
- リポジトリ命名（例: `IEntityNameRepository`）
- DTO命名（例: `EntityNameRequest`、`EntityNameResponse`）
- CRUD操作のメソッド命名パターン
- 変数命名規約
- ファイル組織パターン

#### 12. 実装テンプレート
以下の再利用可能なコードテンプレートを提供:
- パターンに従った新しいAPIエンドポイントの作成
- 新しいサービスメソッドの実装
- 新しいリポジトリメソッドの追加
- 新しいドメインモデルクラスの作成
- 適切なエラーハンドリングの実装

### 技術固有実装パターン

**.NET実装パターン（検出された場合）:**
```
${PROJECT_TYPE == ".NET" || PROJECT_TYPE == "自動検出" ? 
  "- 属性、フィルター、依存性注入を含む完全なコントローラークラス
   - Startup.csまたはProgram.csでのサービス登録
   - Entity Framework DbContext設定
   - EF CoreまたはDapperを使用したリポジトリ実装
   - AutoMapperプロファイル設定
   - 横断的関心事のミドルウェア実装
   - 拡張メソッドパターン
   - 設定のOptionsパターン実装
   - ILoggerを使用したログ実装
   - 認証/認可フィルターまたはポリシー実装" : ""}
```

**Spring実装パターン（検出された場合）:**
```
${PROJECT_TYPE == "Java" || PROJECT_TYPE == "Spring" || PROJECT_TYPE == "自動検出" ? 
  "- アノテーションと依存性注入を含む完全なコントローラークラス
   - トランザクション境界を含むサービス実装
   - リポジトリインターフェースと実装
   - 関係を含むJPAエンティティ定義
   - DTOクラス実装
   - Beanの設定とコンポーネントスキャニング
   - 例外ハンドラー実装
   - カスタムバリデーター実装" : ""}
```

**React実装パターン（検出された場合）:**
```
${PROJECT_TYPE == "React" || PROJECT_TYPE == "自動検出" ? 
  "- propsとstateを含むコンポーネント構造
   - フック実装パターン（useState、useEffect、カスタムフック）
   - APIサービス実装
   - 状態管理パターン（Context、Redux）
   - フォーム処理実装
   - ルート設定" : ""}
```

### 実装ガイドライン

文書化されたワークフローに基づいて、新機能実装の具体的なガイダンスを提供:

#### 1. 段階的実装プロセス
- 類似機能を追加する際の開始地点
- 実装順序（例: モデル → リポジトリ → サービス → コントローラー）
- 既存の横断的関心事との統合方法

#### 2. 回避すべき一般的な落とし穴
- 現在の実装でエラーが起こりやすい領域を特定
- パフォーマンス考慮事項を注記
- 遭遇する一般的なバグや問題をリスト

#### 3. 拡張メカニズム
- 既存の拡張ポイントへのプラグイン方法を文書化
- 既存のコードを変更せずに新しい動作を追加する方法を表示
- 設定駆動機能パターンを説明

**結論:**
新機能を実装する際にコードベースとの一貫性を維持するために従うべき最重要パターンの要約で締めくくります。"