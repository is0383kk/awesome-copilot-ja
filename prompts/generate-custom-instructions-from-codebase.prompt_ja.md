---
description: 'GitHub Copilot 用のマイグレーションおよびコード進化指示ジェネレーター。2つのプロジェクトバージョン（ブランチ、コミット、リリース）間の差異を分析し、技術マイグレーション、大規模リファクタリング、フレームワークバージョンアップグレード中に Copilot が一貫性を保つことを可能にする精密な指示を作成します。'
mode: 'agent'
---

# マイグレーションおよびコード進化指示ジェネレーター

## 設定変数

```
${MIGRATION_TYPE="Framework Version|Architecture Refactoring|Technology Migration|Dependencies Update|Pattern Changes"}
<!-- マイグレーションまたは進化のタイプ -->

${SOURCE_REFERENCE="branch|commit|tag"}
<!-- ソース参照ポイント（変更前の状態） -->

${TARGET_REFERENCE="branch|commit|tag"}  
<!-- ターゲット参照ポイント（変更後の状態） -->

${ANALYSIS_SCOPE="Entire project|Specific folder|Modified files only"}
<!-- 分析のスコープ -->

${CHANGE_FOCUS="Breaking Changes|New Conventions|Obsolete Patterns|API Changes|Configuration"}
<!-- 変更の主な側面 -->

${AUTOMATION_LEVEL="Conservative|Balanced|Aggressive"}
<!-- Copilot 提案の自動化レベル -->

${GENERATE_EXAMPLES="true|false"}
<!-- 変換例を含めるかどうか -->

${VALIDATION_REQUIRED="true|false"}
<!-- 適用前の検証が必要かどうか -->
```

## 生成されたプロンプト

```
"2つのプロジェクト状態間のコード進化を分析し、GitHub Copilot 用の精密なマイグレーション指示を生成します。これらの指示は、将来の修正時に同じ変換パターンを自動的に適用するように Copilot をガイドします。この方法論に従ってください：

### フェーズ 1：比較状態分析

#### 構造変更の検出
- ${SOURCE_REFERENCE} と ${TARGET_REFERENCE} 間のフォルダー構造を比較
- 移動、名前変更、または削除されたファイルを特定
- 設定ファイルの変更を分析
- 新しい依存関係と削除された依存関係を文書化

#### コード変換分析
${MIGRATION_TYPE == "Framework Version" ? 
  "- フレームワークバージョン間の API 変更を特定
   - 使用されている新機能を分析
   - 廃止されたメソッド/プロパティを文書化
   - 構文や規則の変更を記録" : ""}

${MIGRATION_TYPE == "Architecture Refactoring" ? 
  "- アーキテクチャパターンの変更を分析
   - 導入された新しい抽象化を特定
   - 責任の再組織を文書化
   - データフローの変更を記録" : ""}

${MIGRATION_TYPE == "Technology Migration" ? 
  "- ある技術から別の技術への置き換えを分析
   - 機能的等価性を特定
   - API と構文の変更を文書化
   - 新しい依存関係と設定を記録" : ""}

#### 変換パターンの抽出
- 適用された反復的変換を特定
- 古い形式から新しい形式への変換ルールを分析
- 例外と特別なケースを文書化
- 変更前後の対応マトリックスを作成

### フェーズ 2：マイグレーション指示の生成

以下の構造で `.github/copilot-migration-instructions.md` ファイルを作成：

\`\`\`markdown
# GitHub Copilot マイグレーション指示

## マイグレーションコンテキスト
- **タイプ**: ${MIGRATION_TYPE}
- **変更前**: ${SOURCE_REFERENCE} 
- **変更後**: ${TARGET_REFERENCE}
- **日付**: [生成日]
- **スコープ**: ${ANALYSIS_SCOPE}

## 自動変換ルール

### 1. 必須変換
${AUTOMATION_LEVEL != "Conservative" ? 
  "[自動変換ルール]
   - **古いパターン**: [古いコード]
   - **新しいパターン**: [新しいコード]
   - **トリガー**: このパターンを検出するタイミング
   - **アクション**: 自動的に適用する変換" : ""}

### 2. 検証付き変換
${VALIDATION_REQUIRED == "true" ? 
  "[検証付き変換]
   - **検出されたパターン**: [説明]
   - **提案された変換**: [新しいアプローチ]
   - **必要な検証**: [検証基準]
   - **代替案**: [代替オプション]" : ""}

### 3. API 対応
${CHANGE_FOCUS == "API Changes" || MIGRATION_TYPE == "Framework Version" ? 
  "[API対応テーブル]
   | 古い API   | 新しい API   | 注記     | 例        |
   | --------- | --------- | --------- | -------------- |
   | [古いAPI] | [新しいAPI] | [変更点] | [コード例] | " : ""} |

### 4. 採用すべき新しいパターン
[検出された新興パターン]
- **パターン**: [パターン名]
- **使用法**: [いつ使用するか] 
- **実装**: [実装方法]
- **利点**: [利点]

### 5. 避けるべき廃止パターン
[検出された廃止パターン]
- **廃止パターン**: [古いパターン]
- **回避理由**: [理由]
- **代替案**: [新しいパターン]
- **マイグレーション**: [変換ステップ]

## ファイルタイプ固有の指示

${GENERATE_EXAMPLES == "true" ? 
  "### 設定ファイル
   [設定変換例]
   
   ### メインソースファイル
   [ソース変換例]
   
   ### テストファイル
   [テスト変換例]" : ""}

## 検証とセキュリティ

### 自動制御ポイント
- 各変換後に実行する検証
- 変更を検証するために実行するテスト
- 監視するパフォーマンスメトリクス
- 実行する互換性チェック

### 手動エスカレーション
人間の介入が必要な状況：
- [複雑なケースリスト]
- [アーキテクチャ決定]
- [ビジネス影響]

## マイグレーション監視

### 追跡メトリクス
- 自動的にマイグレーションされたコードの割合
- 必要な手動検証の数
- 自動変換のエラー率
- ファイル当たりの平均マイグレーション時間

### エラー報告
Copilot に不正確な変換を報告する方法：
- ルール改善のためのフィードバックパターン
- 文書化すべき例外
- 指示に対して行うべき調整

\`\`\`

### フェーズ 3：コンテキスト例の生成

${GENERATE_EXAMPLES == "true" ? 
  "#### 変換例
   特定された各パターンについて以下を生成：
   
   \`\`\`
   // 変更前（${SOURCE_REFERENCE}）
   [古いコード例]
   
   // 変更後（${TARGET_REFERENCE}） 
   [新しいコード例]
   
   // COPILOT 指示
   このパターン [トリガー] を見たら、以下のステップに従って [新しいパターン] に変換してください：[ステップ]
   \`\`\`" : ""}

### フェーズ 4：検証と最適化

#### 指示テスト
- テストコードに指示を適用
- 変換の一貫性を検証
- 結果に基づいてルールを調整
- 例外とエッジケースを文書化

#### 反復最適化  
${AUTOMATION_LEVEL == "Aggressive" ? 
  "- 自動化を最大化するようにルールを洗練
   - 検出の偽陽性を減らす
   - 変換精度を改善
   - 学んだ教訓を文書化" : ""}

### 最終結果

GitHub Copilot が以下を可能にするマイグレーション指示：
1. **自動適用** 将来の修正時に同じ変換を実行
2. **一貫性維持** 新しく採用された規則との一貫性を保持  
3. **廃止パターンの回避** 代替案を自動的に提案することで廃止パターンを回避
4. **将来のマイグレーション加速** 獲得した経験を活用して将来のマイグレーションを高速化
5. **エラー削減** 反復的変換を自動化することでエラーを削減

これらの指示により、Copilot はあなたの技術進化決定を一貫して信頼性高く再現できるインテリジェントなマイグレーションアシスタントに変身します。
"
```

## 典型的な使用例

### フレームワークバージョンマイグレーション
Angular 14 から Angular 17、React クラスコンポーネントから Hooks、.NET Framework から .NET Core への移行を文書化するのに最適です。破壊的変更を自動的に特定し、対応する変換ルールを生成します。

### 技術スタック進化  
技術を完全に置き換える際に必須：jQuery から React、REST から GraphQL、SQL から NoSQL。パターンマッピングを含む包括的なマイグレーションガイドを作成します。

### アーキテクチャリファクタリング
モノリスからマイクロサービス、MVC からクリーンアーキテクチャ、コンポーネントから Composable アーキテクチャなどの大規模リファクタリングに理想的です。将来の類似変換のためのアーキテクチャ知識を保持します。

### デザインパターンのモダン化
新しいパターンの採用に有用：リポジトリパターン、依存関係注入、Observer からリアクティブプログラミング。理論的根拠と実装の違いを文書化します。

## 独自の利点

### 🧠 **人工知能の強化**
従来のマイグレーションドキュメントとは異なり、これらの指示は GitHub Copilot を「訓練」して、将来のコード修正時にあなたの技術進化決定を自動的に再現させます。

### 🔄 **知識の資本化**  
特定のプロジェクト経験を再利用可能なルールに変換し、マイグレーション専門知識の喪失を回避し、将来の類似変換を加速します。

### 🎯 **コンテキスト認識精度**
一般的なアドバイスではなく、あなたの特定のコードベースに合わせた指示を生成し、プロジェクト進化からの実際の変更前後の例を使用します。

### ⚡ **自動一貫性**
新しいコード追加が自動的に新しい規則に従うことを保証し、アーキテクチャの後退を防ぎ、コード進化の一貫性を維持します。