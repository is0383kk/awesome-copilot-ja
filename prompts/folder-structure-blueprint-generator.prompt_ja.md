---
description: 'プロジェクトフォルダー構造を分析・文書化するための包括的な技術非依存プロンプト。プロジェクトタイプ（.NET、Java、React、Angular、Python、Node.js、Flutter）を自動検出し、可視化オプション、命名規則、ファイル配置パターン、多様な技術スタック間で一貫したコード組織を維持するための拡張テンプレートを含む詳細な設計図を生成します。'
mode: 'agent'
---

# プロジェクトフォルダー構造設計図ジェネレーター

## 設定変数

${PROJECT_TYPE="Auto-detect|.NET|Java|React|Angular|Python|Node.js|Flutter|Other"} 
<!-- 主要技術を選択 -->

${INCLUDES_MICROSERVICES="Auto-detect|true|false"} 
<!-- これはマイクロサービスアーキテクチャですか？ -->

${INCLUDES_FRONTEND="Auto-detect|true|false"} 
<!-- プロジェクトにフロントエンドコンポーネントが含まれますか？ -->

${IS_MONOREPO="Auto-detect|true|false"} 
<!-- これは複数のプロジェクトを含むモノレポですか？ -->

${VISUALIZATION_STYLE="ASCII|Markdown List|Table"} 
<!-- 構造をどのように可視化するか -->

${DEPTH_LEVEL=1-5} 
<!-- フォルダーの何レベルまでを詳細に文書化するか -->

${INCLUDE_FILE_COUNTS=true|false} 
<!-- ファイル数の統計を含めるか -->

${INCLUDE_GENERATED_FOLDERS=true|false} 
<!-- 自動生成フォルダーを含めるか -->

${INCLUDE_FILE_PATTERNS=true|false} 
<!-- ファイル命名/配置パターンを文書化するか -->

${INCLUDE_TEMPLATES=true|false} 
<!-- 新機能用のファイル/フォルダーテンプレートを含めるか -->

## 生成されたプロンプト

"プロジェクトのフォルダー構造を分析し、一貫したコード組織を維持するための決定的ガイドとして機能する包括的な 'Project_Folders_Structure_Blueprint.md' ドキュメントを作成してください。以下のアプローチを使用してください：

### 初期自動検出フェーズ

${PROJECT_TYPE == "Auto-detect" ? 
"まず、プロジェクトタイプを識別するキーファイルのフォルダー構造をスキャンしてください：
- .NET プロジェクトを識別するためのソリューション/プロジェクトファイル（.sln、.csproj、.fsproj、.vbproj）を探す
- Java プロジェクト用のビルドファイル（pom.xml、build.gradle、settings.gradle）をチェック
- JavaScript/TypeScript プロジェクト用の依存関係を含む package.json を識別
- 特定のフレームワークファイル（angular.json、react-scripts エントリ、next.config.js）を探す
- Python プロジェクトの識別子（requirements.txt、setup.py、pyproject.toml）をチェック
- モバイルアプリの識別子（pubspec.yaml、android/ios フォルダー）を調査
- 見つかったすべての技術シグネチャとそのバージョンを記録" : 
"${PROJECT_TYPE} プロジェクト構造に分析を集中"}

${IS_MONOREPO == "Auto-detect" ? 
"以下を探すことでこれがモノレポかどうかを判断してください：
- 独自の設定ファイルを持つ複数の異なるプロジェクト
- ワークスペース設定ファイル（lerna.json、nx.json、turborepo.json など）
- プロジェクト間の参照と共有依存関係パターン
- ルートレベルのオーケストレーションスクリプトと設定" : ""}

${INCLUDES_MICROSERVICES == "Auto-detect" ? 
"マイクロサービスアーキテクチャの指標をチェック：
- 類似/繰り返し構造を持つ複数のサービスディレクトリ
- サービス固有の Dockerfile またはデプロイメント設定
- サービス間通信パターン（API、メッセージブローカー）
- サービスレジストリまたはディスカバリー設定
- API ゲートウェイ設定ファイル
- サービス間で共有されるライブラリまたはユーティリティ" : ""}

${INCLUDES_FRONTEND == "Auto-detect" ? 
"以下を探すことでフロントエンドコンポーネントを識別：
- Web アセットディレクトリ（wwwroot、public、dist、static）
- UI フレームワークファイル（components、modules、pages）
- フロントエンドビルド設定（webpack、vite、rollup など）
- スタイルシート組織（CSS、SCSS、styled-components）
- 静的アセット組織（images、fonts、icons）" : ""}

### 1. 構造概要

${PROJECT_TYPE == "Auto-detect" ? "検出されたプロジェクトタイプ" : PROJECT_TYPE} プロジェクトの組織原則とフォルダー構造の高レベルな概要を提供：

- フォルダー構造に反映されている全体的なアーキテクチャアプローチを文書化
- 主要な組織原則を識別（機能別、レイヤー別、ドメイン別など）
- コードベース全体で繰り返される構造パターンを記録
- 推測可能な構造の根拠を文書化

${IS_MONOREPO == "Auto-detect" ? 
"モノレポとして検出された場合、モノレポの組織とプロジェクト間の関係を説明してください。" : 
IS_MONOREPO ? "モノレポの組織とプロジェクト間の関係を説明してください。" : ""}

${INCLUDES_MICROSERVICES == "Auto-detect" ? 
"マイクロサービスが検出された場合、それらがどのように構造化され組織されているかを説明してください。" : 
INCLUDES_MICROSERVICES ? "マイクロサービスがどのように構造化され組織されているかを説明してください。" : ""}

### 2. ディレクトリの可視化

${VISUALIZATION_STYLE == "ASCII" ? 
"深度レベル ${DEPTH_LEVEL} までのフォルダー階層の ASCII ツリー表現を作成してください。" : ""}

${VISUALIZATION_STYLE == "Markdown List" ? 
"深度レベル ${DEPTH_LEVEL} までのフォルダー階層を表現するためにネストされたマークダウンリストを使用してください。" : ""}

${VISUALIZATION_STYLE == "Table" ? 
"パス、目的、コンテンツタイプ、規則の列を持つテーブルを作成してください。" : ""}

${INCLUDE_GENERATED_FOLDERS ? 
"生成されたものも含むすべてのフォルダーを含めてください。" : 
"bin/、obj/、node_modules/ などの自動生成フォルダーを除外してください。"}

### 3. 主要ディレクトリ分析

各重要なディレクトリの目的、内容、パターンを文書化：

${PROJECT_TYPE == "Auto-detect" ? 
"検出された各技術について、観察された使用パターンに基づいてディレクトリ構造を分析：" : ""}

${(PROJECT_TYPE == ".NET" || PROJECT_TYPE == "Auto-detect") ? 
"#### .NET プロジェクト構造（検出された場合）

- **ソリューション組織**: 
  - プロジェクトがどのようにグループ化され関連付けられているか
  - ソリューションフォルダー組織パターン
  - マルチターゲットプロジェクトパターン

- **プロジェクト組織**:
  - 内部フォルダー構造パターン
  - ソースコード組織アプローチ
  - リソース組織
  - プロジェクト依存関係と参照

- **ドメイン/機能組織**:
  - ビジネスドメインや機能がどのように分離されているか
  - ドメイン境界強制パターン

- **レイヤー組織**:
  - 関心の分離（Controllers、Services、Repositories など）
  - レイヤー間の相互作用と依存関係パターン

- **設定管理**:
  - 設定ファイルの場所と目的
  - 環境固有の設定
  - 秘密管理アプローチ

- **テストプロジェクト組織**:
  - テストプロジェクトの構造と命名
  - テストカテゴリと組織
  - テストデータとモックの場所" : ""}

${(PROJECT_TYPE == "React" || PROJECT_TYPE == "Angular" || PROJECT_TYPE == "Auto-detect") ? 
"#### UI プロジェクト構造（検出された場合）

- **コンポーネント組織**:
  - コンポーネントフォルダー構造パターン
  - グループ化戦略（機能別、タイプ別など）
  - 共有 vs 機能固有コンポーネント

- **状態管理**:
  - 状態関連ファイル組織
  - グローバル状態のストア構造
  - ローカル状態管理パターン

- **ルーティング組織**:
  - ルート定義の場所
  - ページ/ビューコンポーネント組織
  - ルートパラメーター処理

- **API 統合**:
  - API クライアント組織
  - サービスレイヤー構造
  - データ取得パターン

- **アセット管理**:
  - 静的リソース組織
  - 画像/メディアファイル構造
  - フォントとアイコン組織
  
- **スタイル組織**:
  - CSS/SCSS ファイル構造
  - テーマ組織
  - スタイルモジュールパターン" : ""}

### 4. ファイル配置パターン

${INCLUDE_FILE_PATTERNS ? 
"異なるタイプのファイルがどこに配置されるべきかを決定するパターンを文書化：

- **設定ファイル**:
  - 異なるタイプの設定の場所
  - 環境固有の設定パターン
  
- **モデル/エンティティ定義**:
  - ドメインモデルが定義される場所
  - データ転送オブジェクト（DTO）の場所
  - スキーマ定義の場所
  
- **ビジネスロジック**:
  - サービス実装の場所
  - ビジネスルール組織
  - ユーティリティとヘルパー関数の配置
  
- **インターフェース定義**:
  - インターフェースと抽象化が定義される場所
  - インターフェースのグループ化と組織方法
  
- **テストファイル**:
  - 単体テストの場所パターン
  - 統合テストの配置
  - テストユーティリティとモックの場所
  
- **ドキュメントファイル**:
  - API ドキュメントの配置
  - 内部ドキュメント組織
  - README ファイル配布" : 
"プロジェクトで主要なファイルタイプがどこに配置されているかを文書化。"}

### 5. 命名と組織規則
プロジェクト全体で観察される命名と組織規則を文書化：

- **ファイル命名パターン**:
  - ケース規則（PascalCase、camelCase、kebab-case）
  - プレフィックスとサフィックスパターン
  - ファイル名でのタイプ指標

- **フォルダー命名パターン**:
  - 異なるフォルダータイプの命名規則
  - 階層命名パターン
  - グループ化とカテゴリ化規則

- **名前空間/モジュールパターン**:
  - 名前空間/モジュールがフォルダー構造にどのようにマッピングされるか
  - import/using ステートメント組織
  - 内部 vs パブリック API の分離

- **組織パターン**:
  - コード共存戦略
  - 機能カプセル化アプローチ
  - 横断的関心事組織

### 6. ナビゲーションと開発ワークフロー
コードベース構造のナビゲーションと作業のためのガイダンスを提供：

- **エントリポイント**:
  - メインアプリケーションエントリポイント
  - 主要設定開始ポイント
  - プロジェクトを理解するための初期ファイル

- **一般的な開発タスク**:
  - 新機能を追加する場所
  - 既存機能を拡張する方法
  - 新しいテストを配置する場所
  - 設定変更場所

- **依存関係パターン**:
  - フォルダー間で依存関係がどのように流れるか
  - import/参照パターン
  - 依存関係注入登録場所

${INCLUDE_FILE_COUNTS ? 
"- **コンテンツ統計**:
  - ディレクトリごとのファイル分析
  - コード配布メトリクス
  - 複雑性集中エリア" : ""}

### 7. ビルドと出力組織
ビルドプロセスと出力組織を文書化：

- **ビルド設定**:
  - ビルドスクリプトの場所と目的
  - ビルドパイプライン組織
  - ビルドタスク定義

- **出力構造**:
  - コンパイル/ビルド出力場所
  - 出力組織パターン
  - 配布パッケージ構造

- **環境固有ビルド**:
  - 開発 vs 本番の違い
  - 環境設定戦略
  - ビルドバリアント組織

### 8. 技術固有組織

${(PROJECT_TYPE == ".NET" || PROJECT_TYPE == "Auto-detect") ? 
"#### .NET 固有構造パターン（検出された場合）

- **プロジェクトファイル組織**:
  - プロジェクトファイル構造とパターン
  - ターゲットフレームワーク設定
  - プロパティグループ組織
  - アイテムグループパターン

- **アセンブリ組織**:
  - アセンブリ命名パターン
  - マルチアセンブリアーキテクチャ
  - アセンブリ参照パターン

- **リソース組織**:
  - 埋め込みリソースパターン
  - ローカライゼーションファイル構造
  - 静的 Web アセット組織

- **パッケージ管理**:
  - NuGet 設定場所
  - パッケージ参照組織
  - パッケージバージョン管理" : ""}

${(PROJECT_TYPE == "Java" || PROJECT_TYPE == "Auto-detect") ? 
"#### Java 固有構造パターン（検出された場合）

- **パッケージ階層**:
  - パッケージ命名とネスト規則
  - ドメイン vs 技術パッケージ
  - 可視性とアクセスパターン

- **ビルドツール組織**:
  - Maven/Gradle 構造パターン
  - モジュール組織
  - プラグイン設定パターン

- **リソース組織**:
  - リソースフォルダー構造
  - 環境固有リソース
  - プロパティファイル組織" : ""}

${(PROJECT_TYPE == "Node.js" || PROJECT_TYPE == "Auto-detect") ? 
"#### Node.js 固有構造パターン（検出された場合）

- **モジュール組織**:
  - CommonJS vs ESM 組織
  - 内部モジュールパターン
  - サードパーティ依存関係管理

- **スクリプト組織**:
  - npm/yarn スクリプト定義パターン
  - ユーティリティスクリプト場所
  - 開発ツールスクリプト

- **設定管理**:
  - 設定ファイル場所
  - 環境変数管理
  - 秘密管理アプローチ" : ""}

### 9. 拡張と進化
プロジェクト構造がどのように拡張されるよう設計されているかを文書化：

- **拡張ポイント**:
  - 規則を維持しながら新しいモジュール/機能を追加する方法
  - プラグイン/拡張フォルダーパターン
  - カスタマイゼーションディレクトリ構造

- **スケーラビリティパターン**:
  - より大きな機能のために構造がどのようにスケールするか
  - 大きなモジュールを分解するアプローチ
  - コード分割戦略

- **リファクタリングパターン**:
  - 観察される一般的なリファクタリングアプローチ
  - 構造変更の管理方法
  - 段階的再組織パターン

${INCLUDE_TEMPLATES ? 
"### 10. 構造テンプレート

プロジェクト規則に従った新しいコンポーネントを作成するためのテンプレートを提供：

- **新機能テンプレート**:
  - 完全な機能を追加するためのフォルダー構造
  - 必要なファイルタイプとその場所
  - 従うべき命名パターン

- **新コンポーネントテンプレート**:
  - 典型的なコンポーネントのディレクトリ構造
  - 含めるべき必須ファイル
  - 既存構造との統合ポイント

- **新サービステンプレート**:
  - 新しいサービスを追加するための構造
  - インターフェースと実装の配置
  - 設定と登録パターン

- **新テスト構造**:
  - テストプロジェクト/ファイルのフォルダー構造
  - テストファイル組織テンプレート
  - テストリソース組織" : ""}

### ${INCLUDE_TEMPLATES ? "11" : "10"}. 構造強制

プロジェクト構造がどのように維持・強制されるかを文書化：

- **構造検証**:
  - 構造を強制するツール/スクリプト
  - 構造コンプライアンスのビルドチェック
  - 構造に関連するリンティングルール

- **ドキュメント慣行**:
  - 構造変更の文書化方法
  - アーキテクチャ決定が記録される場所
  - 構造進化履歴

この設計図の維持と最後に更新された日時についてのセクションを最後に含めてください。
"