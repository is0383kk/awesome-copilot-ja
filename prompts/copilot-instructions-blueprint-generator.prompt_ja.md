---
description: 'プロジェクトの標準、アーキテクチャパターン、正確な技術バージョンに一致したコードを生成するよう GitHub Copilot をガイドする包括的な copilot-instructions.md ファイルを作成するための技術非依存ブループリントジェネレーター。既存コードベースパターンの分析による、前提を避けたアプローチ。'
mode: 'agent'
---

# Copilot Instructions Blueprint Generator

## 設定変数
${PROJECT_TYPE="Auto-detect|.NET|Java|JavaScript|TypeScript|React|Angular|Python|Multiple|Other"} <!-- プライマリ技術 -->
${ARCHITECTURE_STYLE="Layered|Microservices|Monolithic|Domain-Driven|Event-Driven|Serverless|Mixed"} <!-- アーキテクチャアプローチ -->
${CODE_QUALITY_FOCUS="Maintainability|Performance|Security|Accessibility|Testability|All"} <!-- 品質の優先度 -->
${DOCUMENTATION_LEVEL="Minimal|Standard|Comprehensive"} <!-- ドキュメント要件 -->
${TESTING_REQUIREMENTS="Unit|Integration|E2E|TDD|BDD|All"} <!-- テストアプローチ -->
${VERSIONING="Semantic|CalVer|Custom"} <!-- バージョニングアプローチ -->

## 生成されるプロンプト

"プロジェクトの標準、アーキテクチャ、技術バージョンに一致したコードを生成するよう GitHub Copilot をガイドする包括的な copilot-instructions.md ファイルを生成してください。この指示は、コードベース内の実際のコードパターンに厳密に基づき、前提を避ける必要があります。以下のアプローチに従ってください：

### 1. コアインストラクション構造

```markdown
# GitHub Copilot Instructions

## 優先ガイドライン

このリポジトリでコードを生成する際は：

1. **バージョン互換性**: プロジェクトで使用されている言語、フレームワーク、ライブラリの正確なバージョンを常に検出し、尊重する
2. **コンテキストファイル**: .github/copilot ディレクトリで定義されているパターンと標準を優先する
3. **コードベースパターン**: コンテキストファイルが具体的なガイダンスを提供しない場合、確立されたパターンのためにコードベースをスキャンする
4. **アーキテクチャ一貫性**: ${ARCHITECTURE_STYLE} アーキテクチャスタイルと確立された境界を維持する
5. **コード品質**: 生成されるすべてのコードで ${CODE_QUALITY_FOCUS == "All" ? "保守性、パフォーマンス、セキュリティ、アクセシビリティ、テスト可能性" : CODE_QUALITY_FOCUS} を優先する

## 技術バージョン検出

コードを生成する前に、コードベースをスキャンして以下を特定する：

1. **言語バージョン**: 使用されているプログラミング言語の正確なバージョンを検出
   - プロジェクトファイル、設定ファイル、パッケージマネージャーを調査
   - 言語固有のバージョンインジケーター（例：.NET プロジェクトの <LangVersion>）を探す
   - 検出されたバージョンを超える言語機能は使用しない

2. **フレームワークバージョン**: すべてのフレームワークの正確なバージョンを特定
   - package.json、.csproj、pom.xml、requirements.txt などをチェック
   - コードを生成する際はバージョン制約を尊重する
   - 検出されたフレームワークバージョンで利用できない機能を提案しない

3. **ライブラリバージョン**: 主要なライブラリと依存関係の正確なバージョンを記録
   - これらの特定のバージョンと互換性のあるコードを生成
   - 検出されたバージョンで利用できない API や機能は使用しない

## コンテキストファイル

.github/copilot ディレクトリ内の以下のファイルを優先する（存在する場合）：

- **architecture.md**: システムアーキテクチャガイドライン
- **tech-stack.md**: 技術バージョンとフレームワーク詳細
- **coding-standards.md**: コードスタイルとフォーマット標準
- **folder-structure.md**: プロジェクト構成ガイドライン
- **exemplars.md**: 従うべき模範的なコードパターン

## コードベーススキャン指示

コンテキストファイルが具体的なガイダンスを提供しない場合：

1. 変更または作成されるファイルと類似のファイルを特定する
2. 以下のパターンを分析する：
   - 命名規約
   - コード構成
   - エラー処理
   - ログアプローチ
   - ドキュメントスタイル
   - テストパターン
   
3. コードベースで見つかった最も一貫性のあるパターンに従う
4. 競合するパターンが存在する場合、新しいファイルまたはテストカバレッジが高いファイルのパターンを優先する
5. 既存のコードベースにないパターンは導入しない

## コード品質標準

${CODE_QUALITY_FOCUS.includes("Maintainability") || CODE_QUALITY_FOCUS == "All" ? `### 保守性
- 明確な命名による自己文書化コードを記述
- コードベースで明らかな命名と構成規約に従う
- 一貫性のために確立されたパターンに従う
- 関数を単一責任に集中させる
- 既存のパターンに合わせて関数の複雑さと長さを制限する` : ""}

${CODE_QUALITY_FOCUS.includes("Performance") || CODE_QUALITY_FOCUS == "All" ? `### パフォーマンス
- メモリとリソース管理の既存パターンに従う
- 計算コストの高い操作の処理について既存パターンに合わせる
- 非同期操作の確立されたパターンに従う
- 既存パターンと一貫性を保ってキャッシュを適用する
- コードベースで明らかなパターンに従って最適化する` : ""}

${CODE_QUALITY_FOCUS.includes("Security") || CODE_QUALITY_FOCUS == "All" ? `### セキュリティ
- 入力検証の既存パターンに従う
- コードベースで使用されているサニタイゼーション技術と同じものを適用する
- 既存パターンに合致するパラメータ化クエリを使用する
- 確立された認証・認可パターンに従う
- 既存パターンに従って機密データを処理する` : ""}

${CODE_QUALITY_FOCUS.includes("Accessibility") || CODE_QUALITY_FOCUS == "All" ? `### アクセシビリティ
- コードベースの既存アクセシビリティパターンに従う
- 既存コンポーネントと ARIA 属性の使用方法を合わせる
- 既存コードと一貫性のあるキーボードナビゲーションサポートを維持する
- 色とコントラストの確立されたパターンに従う
- コードベースと一貫性のあるテキスト代替パターンを適用する` : ""}

${CODE_QUALITY_FOCUS.includes("Testability") || CODE_QUALITY_FOCUS == "All" ? `### テスト可能性
- テスト可能なコードの確立されたパターンに従う
- コードベースで使用されている依存性注入アプローチに合わせる
- 依存関係管理について同じパターンを適用する
- 確立されたモッキングとテストダブルパターンに従う
- 既存テストで使用されているテストスタイルに合わせる` : ""}

## ドキュメント要件

${DOCUMENTATION_LEVEL == "Minimal" ? 
`- 既存コードで見つかるコメントのレベルとスタイルに合わせる
- コードベースで観察されるパターンに従ってドキュメント化する
- 非自明な動作をドキュメント化する既存パターンに従う
- 既存コードと同じフォーマットでパラメータ説明を使用する` : ""}

${DOCUMENTATION_LEVEL == "Standard" ? 
`- コードベースで見つかる正確なドキュメントフォーマットに従う
- 既存コメントの XML/JSDoc スタイルと完全性に合わせる
- 同じスタイルでパラメータ、戻り値、例外をドキュメント化する
- 使用例の既存パターンに従う
- クラスレベルドキュメントのスタイルと内容に合わせる` : ""}

${DOCUMENTATION_LEVEL == "Comprehensive" ? 
`- コードベースで見つかる最も詳細なドキュメントパターンに従う
- 最も良くドキュメント化されたコードのスタイルと完全性に合わせる
- 最も徹底的にドキュメント化されたファイルと同様にドキュメント化する
- ドキュメントをリンクする既存パターンに従う
- 設計決定の説明における詳細レベルに合わせる` : ""}

## テストアプローチ

${TESTING_REQUIREMENTS.includes("Unit") || TESTING_REQUIREMENTS == "All" ? 
`### ユニットテスト
- 既存ユニットテストの正確な構造とスタイルに合わせる
- テストクラスとメソッドについて同じ命名規約に従う
- 既存テストで見つかる同じアサーションパターンを使用する
- コードベースで使用されている同じモッキングアプローチを適用する
- テスト分離の既存パターンに従う` : ""}

${TESTING_REQUIREMENTS.includes("Integration") || TESTING_REQUIREMENTS == "All" ? 
`### 統合テスト
- コードベースで見つかる同じ統合テストパターンに従う
- テストデータのセットアップとティアダウンの既存パターンに合わせる
- コンポーネント間相互作用のテストについて同じアプローチを使用する
- システム動作検証の既存パターンに従う` : ""}

${TESTING_REQUIREMENTS.includes("E2E") || TESTING_REQUIREMENTS == "All" ? 
`### エンドツーエンドテスト
- 既存の E2E テスト構造とパターンに合わせる
- UI テストの確立されたパターンに従う
- ユーザージャーニー検証について同じアプローチを適用する` : ""}

${TESTING_REQUIREMENTS.includes("TDD") || TESTING_REQUIREMENTS == "All" ? 
`### テスト駆動開発
- コードベースで明らかな TDD パターンに従う
- 既存コードで見られるテストケースの進行に合わせる
- テスト通過後の同じリファクタリングパターンを適用する` : ""}

${TESTING_REQUIREMENTS.includes("BDD") || TESTING_REQUIREMENTS == "All" ? 
`### 振る舞い駆動開発
- テストの既存 Given-When-Then 構造に合わせる
- 振る舞い記述について同じパターンに従う
- テストケースでの同じレベルのビジネス焦点を適用する` : ""}

## 技術固有ガイドライン

${PROJECT_TYPE == ".NET" || PROJECT_TYPE == "Auto-detect" || PROJECT_TYPE == "Multiple" ? `### .NET ガイドライン
- 使用中の特定の .NET バージョンを検出し、厳密に遵守する
- 検出されたバージョンと互換性のある C# 言語機能のみを使用する
- コードベースに表示される通りに LINQ 使用パターンに従う
- 既存コードから async/await 使用パターンに合わせる
- コードベースで使用されている同じ依存性注入アプローチを適用する
- 既存コードで見つかる同じコレクション型とパターンを使用する` : ""}

${PROJECT_TYPE == "Java" || PROJECT_TYPE == "Auto-detect" || PROJECT_TYPE == "Multiple" ? `### Java ガイドライン
- 使用中の特定の Java バージョンを検出し、遵守する
- コードベースで見つかる正確に同じ設計パターンに従う
- 既存コードから例外処理パターンに合わせる
- コードベースで見つかる同じコレクション型とアプローチを使用する
- 既存コードで明らかな依存性注入パターンを適用する` : ""}

${PROJECT_TYPE == "JavaScript" || PROJECT_TYPE == "TypeScript" || PROJECT_TYPE == "Auto-detect" || PROJECT_TYPE == "Multiple" ? `### JavaScript/TypeScript ガイドライン
- 使用中の特定の ECMAScript/TypeScript バージョンを検出し、遵守する
- コードベースで見つかる同じモジュールインポート/エクスポートパターンに従う
- TypeScript 型定義を既存パターンと合わせる
- 既存コードと同じ async パターン（Promise、async/await）を使用する
- 類似ファイルからエラー処理パターンに従う` : ""}

${PROJECT_TYPE == "React" || PROJECT_TYPE == "Auto-detect" || PROJECT_TYPE == "Multiple" ? `### React ガイドライン
- 使用中の特定の React バージョンを検出し、遵守する
- 既存コンポーネントからコンポーネント構造パターンに合わせる
- コードベースで見つかる同じフックとライフサイクルパターンに従う
- 既存コンポーネントで使用されている同じ状態管理アプローチを適用する
- 既存コードから prop 型付けと検証パターンに合わせる` : ""}

${PROJECT_TYPE == "Angular" || PROJECT_TYPE == "Auto-detect" || PROJECT_TYPE == "Multiple" ? `### Angular ガイドライン
- 使用中の特定の Angular バージョンを検出し、遵守する
- コードベースで見つかる同じコンポーネントとモジュールパターンに従う
- 既存コードで見られる通りにデコレーター使用を正確に合わせる
- コードベースで見つかる同じ RxJS パターンを適用する
- コンポーネント通信の既存パターンに従う` : ""}

${PROJECT_TYPE == "Python" || PROJECT_TYPE == "Auto-detect" || PROJECT_TYPE == "Multiple" ? `### Python ガイドライン
- 使用中の特定の Python バージョンを検出し、遵守する
- 既存モジュールで見つかる同じインポート構成に従う
- コードベースで使用されている場合は型ヒントアプローチに合わせる
- 既存コードで見つかる同じエラー処理パターンを適用する
- 同じモジュール構成パターンに従う` : ""}

## バージョン管理ガイドライン

${VERSIONING == "Semantic" ? 
`- コードベースで適用されている Semantic Versioning パターンに従う
- 破壊的変更をドキュメント化する既存パターンに合わせる
- 非推奨通知について同じアプローチに従う` : ""}

${VERSIONING == "CalVer" ? 
`- コードベースで適用されている Calendar Versioning パターンに従う
- 変更をドキュメント化する既存パターンに合わせる
- 重要な変更を強調する同じアプローチに従う` : ""}

${VERSIONING == "Custom" ? 
`- コードベースで観察される正確なバージョニングパターンに合わせる
- 既存ドキュメントで使用されている同じ変更履歴フォーマットに従う
- プロジェクトで使用されている同じタグ付け規約を適用する` : ""}

## 一般ベストプラクティス

- 既存コードに表示される通りに命名規約に従う
- 類似ファイルからコード構成パターンに合わせる
- 既存パターンと一貫性のあるエラー処理を適用する
- コードベースで見られるテストと同じアプローチに従う
- 既存コードからログパターンに合わせる
- コードベースで見られる設定と同じアプローチを使用する

## プロジェクト固有ガイダンス

- コードを生成する前にコードベースを徹底的にスキャンする
- 例外なく既存のアーキテクチャ境界を尊重する
- 周囲コードのスタイルとパターンに合わせる
- 迷った場合、外部ベストプラクティスより既存コードとの一貫性を優先する
```

### 2. コードベース分析指示

copilot-instructions.md ファイルを作成するために、まずコードベースを分析して：

1. **正確な技術バージョンの特定**:
   - ${PROJECT_TYPE == "Auto-detect" ? "ファイル拡張子と設定ファイルをスキャンしてすべてのプログラミング言語、フレームワーク、ライブラリを検出" : `${PROJECT_TYPE} 技術に焦点を当てる`}
   - プロジェクトファイル、package.json、.csproj などから正確なバージョン情報を抽出
   - バージョン制約と互換性要件をドキュメント化

2. **アーキテクチャの理解**:
   - フォルダ構造とモジュール構成を分析
   - 明確な層境界とコンポーネント関係を特定
   - コンポーネント間の通信パターンをドキュメント化

3. **コードパターンのドキュメント化**:
   - 異なるコード要素の命名規約をカタログ化
   - ドキュメントスタイルと完全性を記録
   - エラー処理パターンをドキュメント化
   - テストアプローチとカバレッジをマップ

4. **品質標準の記録**:
   - 実際に使用されているパフォーマンス最適化技術を特定
   - コードで実装されているセキュリティプラクティスをドキュメント化
   - 存在するアクセシビリティ機能を記録（該当する場合）
   - コードベースで明らかなコード品質パターンをドキュメント化

### 3. 実装ノート

最終的な copilot-instructions.md は：
- .github/copilot ディレクトリに配置する
- コードベースに存在するパターンと標準のみを参照する
- 明示的なバージョン互換性要件を含む
- コードで明らかでないプラクティスを規定することは避ける
- コードベースからの具体例を提供する
- Copilot が効果的に使用できるよう包括的でありながら簡潔である

重要: コードベースで実際に観察されるパターンに基づくガイダンスのみを含める。外部ベストプラクティスや新しい言語機能より既存コードとの一貫性を優先するよう Copilot に明示的に指示する。
"

## 期待される出力

既存の技術バージョンと完全に互換性があり、確立されたパターンとアーキテクチャに従うコードを生成するよう GitHub Copilot をガイドする包括的な copilot-instructions.md ファイル。