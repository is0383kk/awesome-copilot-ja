---
description: 'コードベースを分析して詳細なアーキテクチャドキュメントを作成する包括的な技術スタック設計図生成ツール。複数のプラットフォーム（.NET、Java、JavaScript、React、Python）で技術スタック、プログラミング言語、実装パターンを自動検出します。バージョン情報、ライセンス詳細、使用パターン、コーディング規約、視覚的図表を含む設定可能な設計図を生成します。実装対応テンプレートを提供し、ガイド付き開発のためのアーキテクチャ一貫性を維持します。'
mode: 'agent'
---

# 包括的技術スタック設計図生成ツール

## 設定変数
${PROJECT_TYPE="自動検出|.NET|Java|JavaScript|React.js|React Native|Angular|Python|その他"} <!-- 主要技術 -->
${DEPTH_LEVEL="基本|標準|包括的|実装対応"} <!-- 分析深度 -->
${INCLUDE_VERSIONS=true|false} <!-- バージョン情報を含める -->
${INCLUDE_LICENSES=true|false} <!-- ライセンス情報を含める -->
${INCLUDE_DIAGRAMS=true|false} <!-- アーキテクチャ図を生成 -->
${INCLUDE_USAGE_PATTERNS=true|false} <!-- コード使用パターンを含める -->
${INCLUDE_CONVENTIONS=true|false} <!-- コーディング規約を文書化 -->
${OUTPUT_FORMAT="Markdown|JSON|YAML|HTML"} <!-- 出力形式を選択 -->
${CATEGORIZATION="技術タイプ|レイヤー|目的"} <!-- 整理方法 -->

## 生成されるプロンプト

「コードベースを分析し、一貫したコード生成を促進するために技術と実装パターンを詳細に文書化する ${DEPTH_LEVEL} の技術スタック設計図を生成してください。以下のアプローチを使用してください：

### 1. 技術識別フェーズ
- ${PROJECT_TYPE == "自動検出" ? "プロジェクトファイル、設定ファイル、依存関係をスキャンして使用中のすべての技術スタックを判定" : "${PROJECT_TYPE} 技術に焦点を当てる"}
- ファイル拡張子とコンテンツを調査してすべてのプログラミング言語を特定
- 設定ファイル（package.json、.csproj、pom.xmlなど）を分析して依存関係を抽出
- ビルドスクリプトとパイプライン定義を調査してツール情報を取得
- ${INCLUDE_VERSIONS ? "パッケージファイルと設定から正確なバージョン情報を抽出" : "バージョン詳細をスキップ"}
- ${INCLUDE_LICENSES ? "すべての依存関係のライセンス情報を文書化" : ""}

### 2. 主要技術分析

${PROJECT_TYPE == ".NET" || PROJECT_TYPE == "自動検出" ? "#### .NETスタック分析（検出された場合）
- ターゲットフレームワークと言語バージョン（プロジェクトファイルから検出）
- すべてのNuGetパッケージ参照をバージョンと目的コメント付きで
- プロジェクト構造と整理パターン
- 設定アプローチ（appsettings.json、IOptionsなど）
- 認証メカニズム（Identity、JWTなど）
- API設計パターン（REST、GraphQL、minimal APIsなど）
- データアクセスアプローチ（EF Core、Dapperなど）
- 依存性注入パターン
- ミドルウェアパイプラインコンポーネント" : ""}

${PROJECT_TYPE == "Java" || PROJECT_TYPE == "自動検出" ? "#### Javaスタック分析（検出された場合）
- JDKバージョンとコアフレームワーク
- すべてのMaven/Gradle依存関係をバージョンと目的付きで
- パッケージ構造組織
- Spring Bootの使用と設定
- アノテーションパターン
- 依存性注入アプローチ
- データアクセス技術（JPA、JDBCなど）
- API設計（Spring MVC、JAX-RSなど）" : ""}

${PROJECT_TYPE == "JavaScript" || PROJECT_TYPE == "自動検出" ? "#### JavaScriptスタック分析（検出された場合）
- ECMAScriptバージョンとトランスパイラー設定
- 目的別に分類されたすべてのnpm依存関係
- モジュールシステム（ESM、CommonJS）
- 設定付きビルドツール（webpack、Viteなど）
- TypeScriptの使用と設定
- テストフレームワークとパターン" : ""}

${PROJECT_TYPE == "React.js" || PROJECT_TYPE == "自動検出" ? "#### React分析（検出された場合）
- Reactバージョンと主要パターン（hooks vs クラスコンポーネント）
- 状態管理アプローチ（Context、Redux、Zustandなど）
- コンポーネントライブラリの使用（Material-UI、Chakraなど）
- ルーティング実装
- フォーム処理戦略
- API統合パターン
- コンポーネントのテストアプローチ" : ""}

${PROJECT_TYPE == "Python" || PROJECT_TYPE == "自動検出" ? "#### Python分析（検出された場合）
- Pythonバージョンと使用される主要言語機能
- パッケージ依存関係と仮想環境セットアップ
- Webフレームワーク詳細（Django、Flask、FastAPI）
- ORM使用パターン
- プロジェクト構造組織
- API設計パターン" : ""}

### 3. 実装パターンと規約
${INCLUDE_CONVENTIONS ? 
"各技術エリアのコーディング規約とパターンを文書化：

#### 命名規約
- クラス/タイプ命名パターン
- メソッド/関数命名パターン
- 変数命名規約
- ファイル命名と組織規約
- インターフェース/抽象クラスパターン

#### コード組織
- ファイル構造と組織
- フォルダー階層パターン
- コンポーネント/モジュール境界
- コード分離と責任パターン

#### 共通パターン
- エラーハンドリングアプローチ
- ロギングパターン
- 設定アクセス
- 認証/認可実装
- 検証戦略
- テストパターン" : ""}

### 4. 使用例
${INCLUDE_USAGE_PATTERNS ? 
"標準実装パターンを示す代表的なコード例を抽出：

#### API実装例
- 標準コントローラー/エンドポイント実装
- リクエストDTOパターン
- レスポンス形式
- 検証アプローチ
- エラーハンドリング

#### データアクセス例
- リポジトリパターン実装
- エンティティ/モデル定義
- クエリパターン
- トランザクション処理

#### サービスレイヤー例
- サービスクラス実装
- ビジネスロジック組織
- 横断的関心事統合
- 依存性注入使用

#### UIコンポーネント例（該当する場合）
- コンポーネント構造
- 状態管理パターン
- イベントハンドリング
- API統合パターン" : ""}

### 5. 技術スタックマップ
${DEPTH_LEVEL == "包括的" || DEPTH_LEVEL == "実装対応" ? 
"以下を含む包括的な技術マップを作成：

#### コアフレームワーク使用
- プロジェクトでの主要フレームワークとその特定の使用
- フレームワーク固有の設定とカスタマイズ
- 拡張ポイントとカスタマイズ

#### 統合ポイント
- 異なる技術コンポーネントの統合方法
- コンポーネント間の認証フロー
- フロントエンドとバックエンド間のデータフロー
- サードパーティサービス統合パターン

#### 開発ツール
- IDE設定と規約
- コード分析ツール
- 設定付きリンターとフォーマッター
- ビルドとデプロイメントパイプライン
- テストフレームワークとアプローチ

#### インフラストラクチャ
- デプロイメント環境詳細
- コンテナ技術
- 利用されるクラウドサービス
- 監視とロギングインフラストラクチャ" : ""}

### 6. 技術固有実装詳細

${PROJECT_TYPE == ".NET" || PROJECT_TYPE == "自動検出" ? 
"#### .NET実装詳細（検出された場合）
- **依存性注入パターン**：
  - サービス登録アプローチ（Scoped/Singleton/Transientパターン）
  - 設定バインディングパターン
  
- **コントローラーパターン**：
  - ベースコントローラー使用
  - アクション結果タイプとパターン
  - ルート属性規約
  - フィルター使用（認可、検証など）
  
- **データアクセスパターン**：
  - ORM設定と使用
  - エンティティ設定アプローチ
  - リレーションシップ定義
  - クエリパターンと最適化アプローチ
  
- **API設計パターン**（使用されている場合）：
  - エンドポイント組織
  - パラメーターバインディングアプローチ
  - レスポンスタイプハンドリング
  
- **使用される言語機能**：
  - コードから特定の言語機能を検出
  - 共通パターンとイディオムを特定
  - バージョン依存機能をメモ" : ""}

${PROJECT_TYPE == "React.js" || PROJECT_TYPE == "自動検出" ? 
"#### React実装詳細（検出された場合）
- **コンポーネント構造**：
  - 関数 vs クラスコンポーネント
  - Propsインターフェース定義
  - コンポーネント合成パターン
  
- **Hook使用パターン**：
  - カスタムhook実装スタイル
  - useStateパターン
  - useEffectクリーンアップアプローチ
  - Context使用パターン
  
- **状態管理**：
  - ローカル vs グローバル状態決定
  - 状態管理ライブラリパターン
  - ストア設定
  - セレクターパターン
  
- **スタイリングアプローチ**：
  - CSS方法論（CSSモジュール、styled-componentsなど）
  - テーマ実装
  - レスポンシブデザインパターン" : ""}

### 7. 新しいコード実装の設計図
${DEPTH_LEVEL == "実装対応" ? 
"分析に基づいて、新機能実装の詳細な設計図を提供：

- **ファイル/クラステンプレート**：共通コンポーネントタイプの標準構造
- **コードスニペット**：共通操作のすぐに使えるコードパターン
- **実装チェックリスト**：エンドツーエンドでの機能実装の標準ステップ
- **統合ポイント**：新しいコードを既存システムと接続する方法
- **テスト要件**：異なるコンポーネントタイプの標準テストパターン
- **ドキュメント要件**：新機能の標準ドキュメントパターン" : ""}

${INCLUDE_DIAGRAMS ? 
"### 8. 技術関係図
- **スタック図**：完全な技術スタックの視覚的表現
- **依存関係フロー**：異なる技術の相互作用
- **コンポーネント関係**：主要コンポーネントの相互依存
- **データフロー**：技術スタック全体でのデータの流れ" : ""}

### ${INCLUDE_DIAGRAMS ? "9" : "8"}. 技術決定コンテキスト
- 技術選択の明確な理由を文書化
- 置き換え対象とマークされたレガシーまたは非推奨技術をメモ
- 技術制約と境界を特定
- 技術アップグレードパスと互換性考慮事項を文書化

出力を ${OUTPUT_FORMAT} で形式化し、技術を ${CATEGORIZATION} で分類してください。

出力を「Technology_Stack_Blueprint.${OUTPUT_FORMAT == "Markdown" ? "md" : OUTPUT_FORMAT.toLowerCase()}」として保存してください。
"