---
mode: 'agent'
description: '新しい要件や既存のコードへの更新に基づいて、ソリューションの既存仕様ファイルを更新します。生成AIによる消費に最適化されています。'
tools: ['changes', 'codebase', 'editFiles', 'extensions', 'fetch', 'githubRepo', 'openSimpleBrowser', 'problems', 'runTasks', 'search', 'searchResults', 'terminalLastCommand', 'terminalSelection', 'testFailure', 'usages', 'vscodeAPI']
---
# 仕様の更新

あなたの目標は、新しい要件や既存のコードへの更新に基づいて、既存の仕様ファイル `${file}` を更新することです。

仕様ファイルは、生成AIによる効果的な使用のために、明確で曖昧さがなく構造化された方法で、ソリューションコンポーネントの要件、制約、インターフェースを定義する必要があります。確立されたドキュメント標準に従い、コンテンツが機械可読で自己完結していることを確認してください。

## AI対応仕様のベストプラクティス

- 正確で明示的で曖昧さのない言語を使用する。
- 要件、制約、推奨事項を明確に区別する。
- 解析しやすい構造化フォーマット（見出し、リスト、テーブル）を使用する。
- 慣用句、メタファー、文脈依存の参照を避ける。
- すべての頭字語とドメイン固有の用語を定義する。
- 該当する場合は例とエッジケースを含める。
- ドキュメントが自己完結しており、外部コンテキストに依存しないようにする。

仕様は [/spec/](/spec/) ディレクトリに保存し、以下の規則に従って命名する必要があります：`[a-z0-9-]+.md`。名前は仕様の内容を説明し、高レベルな目的（schema、tool、data、infrastructure、process、architecture、または design のいずれか）で始まる必要があります。

仕様ファイルは適切に構成されたMarkdownでフォーマットする必要があります。

仕様ファイルは、以下のテンプレートに従い、すべてのセクションが適切に記入されていることを確認する必要があります。マークダウンのフロントマターは、以下の例のように正しく構成される必要があります：

```md
---
title: [仕様の焦点を説明する簡潔なタイトル]
version: [オプション: 例 1.0、日付]
date_created: [YYYY-MM-DD]
last_updated: [オプション: YYYY-MM-DD]
owner: [オプション: この仕様に責任を持つチーム/個人]
tags: [オプション: 関連するタグやカテゴリのリスト、例：`infrastructure`、`process`、`design`、`app` など]
---

# はじめに

[仕様と達成を意図する目標についての短く簡潔な紹介。]

## 1. 目的とスコープ

[仕様の目的とその適用範囲について、明確で簡潔な説明を提供する。対象読者と前提条件を明記する。]

## 2. 定義

[この仕様で使用されるすべての頭字語、略語、ドメイン固有の用語をリストして定義する。]

## 3. 要件、制約、ガイドライン

[すべての要件、制約、規則、ガイドラインを明示的にリストする。明確にするために箇条書きやテーブルを使用する。]

- **REQ-001**: 要件1
- **SEC-001**: セキュリティ要件1
- **[3文字]-001**: その他の要件1
- **CON-001**: 制約1
- **GUD-001**: ガイドライン1
- **PAT-001**: 従うべきパターン1

## 4. インターフェースとデータ契約

[インターフェース、API、データ契約、統合ポイントについて説明する。スキーマと例にはテーブルやコードブロックを使用する。]

## 5. 受け入れ基準

[Given-When-Then形式を適切に使用して、各要件に対して明確でテスト可能な受け入れ基準を定義する。]

- **AC-001**: Given [コンテキスト], When [アクション], Then [期待される結果]
- **AC-002**: システムは[条件]の場合に[特定の動作]を行うものとする
- **AC-003**: [必要に応じて追加の受け入れ基準]

## 6. テスト自動化戦略

[テストアプローチ、フレームワーク、自動化要件を定義する。]

- **テストレベル**: ユニット、統合、エンドツーエンド
- **フレームワーク**: MSTest、FluentAssertions、Moq（.NETアプリケーションの場合）
- **テストデータ管理**: [テストデータの作成とクリーンアップのアプローチ]
- **CI/CD統合**: [GitHub Actionsパイプラインでの自動テスト]
- **カバレッジ要件**: [最小コードカバレッジ閾値]
- **パフォーマンステスト**: [負荷およびパフォーマンステストのアプローチ]

## 7. 根拠とコンテキスト

[要件、制約、ガイドラインの背後にある理由を説明する。設計決定のコンテキストを提供する。]

## 8. 依存関係と外部統合

[この仕様に必要な外部システム、サービス、アーキテクチャ依存関係を定義する。**どのように**実装するかではなく、**何が**必要かに焦点を当てる。アーキテクチャ制約を表す場合を除き、特定のパッケージやライブラリのバージョンは避ける。]

### 外部システム
- **EXT-001**: [外部システム名] - [目的と統合タイプ]

### サードパーティサービス
- **SVC-001**: [サービス名] - [必要な機能とSLA要件]

### インフラストラクチャ依存関係
- **INF-001**: [インフラストラクチャコンポーネント] - [要件と制約]

### データ依存関係
- **DAT-001**: [外部データソース] - [フォーマット、頻度、アクセス要件]

### テクノロジープラットフォーム依存関係
- **PLT-001**: [プラットフォーム/ランタイム要件] - [バージョン制約と根拠]

### コンプライアンス依存関係
- **COM-001**: [規制またはコンプライアンス要件] - [実装への影響]

**注意**: このセクションは、特定のパッケージ実装ではなく、アーキテクチャとビジネスの依存関係に焦点を当てる必要があります。例えば、「Microsoft.AspNetCore.Authentication.JwtBearer v6.0.1」ではなく「OAuth 2.0認証ライブラリ」と指定してください。

## 9. 例とエッジケース

```code
// エッジケースを含む、ガイドラインの正しい適用を示すコードスニペットやデータ例
```

## 10. 検証基準

[この仕様への準拠のために満たすべき基準やテストをリストする。]

## 11. 関連仕様 / 参考文献

[関連する仕様1へのリンク]
[関連する外部ドキュメントへのリンク]

```