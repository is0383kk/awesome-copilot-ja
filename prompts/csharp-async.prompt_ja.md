---
mode: 'agent'
tools: ['changes', 'codebase', 'editFiles', 'problems']
description: 'C# 非同期プログラミングのベストプラクティスを取得する'
---

# C# 非同期プログラミングのベストプラクティス

C# における非同期プログラミングのベストプラクティスに従うことをサポートします。

## 命名規則

- すべての非同期メソッドに 'Async' サフィックスを使用する
- 該当する場合は、同期版メソッドと名前を合わせる（例：`GetData()` に対して `GetDataAsync()`）

## 戻り値の型

- メソッドが値を返す場合は `Task<T>` を返す
- メソッドが値を返さない場合は `Task` を返す
- ハイパフォーマンスシナリオでは、アロケーションを減らすために `ValueTask<T>` を検討する
- イベントハンドラーを除いて、非同期メソッドが `void` を返すのは避ける

## 例外処理

- await 式の周りでは try/catch ブロックを使用する
- 非同期メソッドで例外を握りつぶさない
- ライブラリコードでデッドロックを防ぐため、適切な場合は `ConfigureAwait(false)` を使用する
- Task を返す非同期メソッドでは、throw する代わりに `Task.FromException()` で例外を伝播させる

## パフォーマンス

- 複数のタスクを並列実行するには `Task.WhenAll()` を使用する
- タイムアウトや最初に完了したタスクを取得するには `Task.WhenAny()` を使用する
- 単純にタスクの結果を通すだけの場合は、不必要な async/await を避ける
- 長時間実行される操作ではキャンセレーショントークンを検討する

## よくある落とし穴

- 非同期コードでは `.Wait()`、`.Result`、`.GetAwaiter().GetResult()` を使用しない
- ブロッキングと非同期コードを混在させない
- async void メソッドを作成しない（イベントハンドラーは除く）
- Task を返すメソッドは常に await する

## 実装パターン

- 長時間実行される操作では非同期コマンドパターンを実装する
- シーケンスを非同期で処理するには非同期ストリーム（IAsyncEnumerable<T>）を使用する
- パブリック API ではタスクベース非同期パターン（TAP）を検討する

私の C# コードをレビューする際は、これらの問題を特定し、これらのベストプラクティスに従った改善提案を行ってください。