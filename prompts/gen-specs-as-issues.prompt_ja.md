---
description: 'このワークフローは、欠けている機能を特定し、優先順位を付け、実装のための詳細な仕様を作成する体系的なアプローチを案内します。'
mode: 'agent'
---

# プロダクトマネージャーアシスタント：機能の特定と仕様

このワークフローは、欠けている機能を特定し、優先順位を付け、実装のための詳細な仕様を作成する体系的なアプローチを案内します。

## 1. プロジェクト理解フェーズ

- プロジェクト構造をレビューして組織を理解する
- README.md と他のドキュメントファイルを読んでプロジェクトのコア機能を理解する
- 以下を調査して既存の実装状況を特定する：
  - メインエントリーポイント（CLI、API、UI など）
  - コアモジュールとその機能
  - 期待される動作を理解するためのテスト
  - プレースホルダー実装

**ガイド質問：**
- このプロジェクトの主な目的は何ですか？
- どのようなユーザー問題を解決しますか？
- 現在の実装にはどのようなパターンが存在しますか？
- ドキュメントに言及されているが完全に実装されていない機能はありますか？

## 2. ギャップ分析フェーズ

- 文書化された機能と実際の実装のみを比較する
- 実際の機能を欠く「プレースホルダー」コードを特定する
- ドキュメントで言及されているが堅牢な実装が欠けている機能を探す
- ユーザージャーニーを考慮し、壊れているまたは欠けているステップを特定する
- まずコア機能に焦点を当てる（あると良い機能ではない）

**出力作成：**
- 潜在的に欠けている機能のリスト（5-7項目）を作成する
- 各機能について以下を記録：
  - 現在の実装状況
  - ドキュメント内の参照
  - 欠けている場合のユーザー体験への影響

## 3. 優先順位付けフェーズ

- 特定された各ギャップにスコアを適用：

**スコアリングマトリックス（1-5スケール）：**
- ユーザー影響：何人のユーザーが利益を得るか？
- 戦略的整合性：コアミッションに適合するか？
- 実装可能性：技術的複雑さ？
- リソース要件：開発努力が必要か？
- リスクレベル：潜在的な負の影響？

**優先順位 = （ユーザー影響 × 戦略的整合性）/ （実装努力 × リスクレベル）**

**出力作成：**
- スコアリングに基づいて最も優先度の高い欠けている機能トップ3を提示
- それぞれについて以下を提供：
  - 機能名
  - 現在の状況
  - 実装されない場合の影響
  - 他の機能への依存関係

## 4. 仕様開発フェーズ

- 優先度の高い各機能について、詳細だが実用的な仕様を開発：
  - 哲学的アプローチから始める：複雑さより簡潔さ
  - まず MVP 機能に焦点を当てる
  - 開発者体験を考慮する
  - 仕様を実装フレンドリーに保つ

**各機能仕様について：**
1. **概要とスコープ**
   - どのような問題を解決するか？
   - 何が含まれ何が明示的に除外されるか？

2. **技術要件**
   - 必要なコア機能
   - ユーザー向けインターフェース（API、UI、CLI など）
   - 既存コードとの統合ポイント

3. **実装計画**
   - 作成または変更する主要モジュール/ファイル
   - アプローチを示すシンプルなコード例
   - 明確なデータ構造とインターフェース

4. **受入基準**
   - 完了をどのように知るか？
   - どのような具体的機能が動作する必要があるか？
   - どのようなテストが通る必要があるか？

## 5. GitHub Issue 作成フェーズ

- 各仕様について、GitHub Issue を作成：
  - 明確で説明的なタイトル
  - 本文に包括的な仕様
  - 適切なラベル（enhancement、high-priority など）
  - 関連する場所で MVP 哲学を明示的に言及

**Issue テンプレート構造：**

# [機能名]

## 概要
[機能とその目的の簡潔な説明]

## スコープ
[含まれるものと明示的に除外されるもの]

## 技術要件
[特定の技術ニーズと制約]

## 実装計画
[シンプルなコード例を含むステップバイステップアプローチ]

## 受入基準
[機能を完了と見なすための明確な要件リスト]

## 優先順位
[優先順位付けの正当化]

## 依存関係
- **ブロック対象:** [これによってブロックされる Issue のリスト]
- **ブロック元:** [これが依存する Issue のリスト]

## 実装サイズ
- **推定努力:** [小/中/大]
- **サブ Issue:** [これが親 Issue の場合のサブ Issue へのリンク]


## 5.5 作業分散の最適化

- **独立性分析**
  - 各仕様をレビューして真に独立したコンポーネントを特定
  - 独立した作業ストリームを最大化するように仕様をリファクタリング
  - 相互依存コンポーネント間の明確な境界を作成

- **依存関係マッピング**
  - 避けられない依存関係を持つ機能について、明確な Issue 階層を確立
  - コンポーネント用のサブ Issue を持つ全体機能の親 Issue を作成
  - 「ブロック元」と「ブロック対象」の関係を明示的に文書化

- **ワークロードバランシング**
  - 大きな仕様をより小さく管理可能なサブ Issue に分解
  - 各サブ Issue が 1-3 日の開発作業を表すことを確保
  - サブ Issue 固有の受入基準を含める

**実装ガイドライン：**
- GitHub Issue リンク構文を使用して明示的な関係を作成
- 依存関係ステータスを示すラベルを追加（例：「ブロック済み」、「前提条件」）
- スプリント計画を支援するために各 Issue の推定複雑性/努力を含める

## 6. 最終レビューフェーズ

- 作成されたすべての仕様を要約
- 機能間の実装依存関係を強調
- 論理的な実装順序を提案
- 潜在的な課題や考慮事項を記録

このプロセス全体を通じて覚えておくこと：
- 複雑さより簡潔さを優先する
- 動作する最小限の実装から始める
- 開発者体験に焦点を当てる
- 後で拡張できる基盤を構築する
- オープンソースコミュニティと貢献モデルを考慮する

このワークフローの具現化により、機能がどのように仕様化され優先順位が付けられるかの一貫性を維持し、ソフトウェアプロジェクトが思慮深く、ユーザー中心の方法で進化することを確保します。